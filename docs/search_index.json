[["index.html", "Exploración y manipulación de datos con R Motivación", " Exploración y manipulación de datos con R Motivación “Una de las cosas más importantes que puedes hacer es dedicar un tiempo para aprender un lenguaje de programación. Aprender a programar es como aprender otro idioma: requiere tiempo y entrenamiento, y no hay resultados prácticos inmediatos. Pero si superas esa primera subida empinada de la curva de aprendizaje, las ganancias como científico son enormes. Programar no sólo te liberará de la camisa de fuerza de los softwares estadísticos cerrados, sino que también agudizará tus habilidades analíticas y ampliará los horizontes de modelado ecológico y estadístico.” ~ Adaptación de (Ellison and Gotelli 2004) ~ ¿Por qué R? (R Core Team 2017) Software libre - multiplataforma Aprender un lenguaje de programación: ejercicio mental/lógica (Mayor aprovechamiento de otros cursos específicos) Amplia gama de paquetes específicos Gran flexibilidad y elegancia de los gráficos Popularidad - Comunidad activa y creciente dispuesta a ayudar (aprendemos a usar terminos técnicos de data science en inglés) Programar ya no es sólo computación (CV/relevant skills) "],["objetivos.html", "Objetivos", " Objetivos Acompañar la primer fase empinada de la curva de aprendizaje de un nuevo lenguaje, que a la larga redituará en multiples beneficios tanto profesionales como personales. Proveer herramientas que optimicen nuestra labor cotidiana como recolectores/analistas de datos a lo largo de todo el flujo de trabajo ~ Adaptación de “R for Data Science” (Wickham and Grolemund 2016) ~ Importante: no es un curso de estadística entendemos la programación como un simple medio para optimizar nuestra labor cotidiana (no como un fin mismo), al final del día seguiremos siendo fitopatólogos, fisiólogos, bioquímicos, etc. maximizaremos la adopción de la filosofía tidyverse "],["config.html", "1 Configuraciones básicas Paquetes de R Proyectos de RStudio", " 1 Configuraciones básicas Instalación de programas 1° R 2° R Studio (bajar la versión Free) RStudio es un entorno de desarrollo integrado (IDE) para el lenguaje de programación R, o sea es la interface por medio de la cual se ejecutan acciones en R. Configuraciones iniciales (sugeridas). Dirigirse a la sección “Tools/Global options” Paquetes de R Un paquete es una colección de funciones, datos y código R que se almacenan en una carpeta conforme a una estructura bien definida, fácilmente accesible para R. Un repositorio es un lugar donde se alojan los paquetes para que pueda instalarlos desde él. Los repositorios mas populares son: CRAN: repositorio oficial. Es una red de servidores web mantenida por la comunidad R en todo el mundo. El Core Team de R lo coordina, y para que un paquete se publique aquí, debe pasar varias pruebas que aseguren el cumplimiento de las políticas de CRAN. GITHUB: probablemente el repositorio más popular para proyectos particulares de código abierto. No es específico de R (sin proceso de revisión asociado). Bioconductor: repositorio destinado a software de código abierto para bioinformática. Como CRAN, tiene sus propios procesos de presentación y revisión, y su comunidad es muy activa y tiene varias conferencias y reuniones al año. La simple instalación de R trae consigo múltiples paquetes que permiten un funcionamiento básico de importación de datos, ajuste y evaluación de modelos estadísticos y representaciones gráficas. Sin embargo, la enorme potencia de R deriva de su capacidad de incorporar nuevas funciones generadas por su gran comunidad de usuarios En la web de R se puede consultar la lista de paquetes disponibles, y en la sección Task Views se puede consultar los mismos ordenados por áreas de aplicación. Links para exploración o chequeo de novedades de paquetes: Rdocumentation METACRAN r weekly r-bloggers revolution analytics RStudio blog Existen varias vias de instalación de paquetes: Via consola: install.packages(\"nombre_del_paquete\") O simplemente en el panel de paquetes. Una vez instalado, hay que cargar los paquetes que contienen las funciones que vayamos a usar en cada sesión library(nombre-del-paquete) instale el paquete pacman y activelo Proyectos de RStudio Varios tipos de archivos serán creados y usados durante una sesión de R: datos crudos (hojas de cálculo) - datos manipulados scripts gráficos reportes de resultados Una análisis debe poder ser retomado en cualquier momento pudiendo darse por concluída cuando el trabajo es publicado. Hasta entonces debemos tener rápido acceso a todos los objetos creados en sesiones anteriores. Para ello debemos manejarnos siempre bajo buenas prácticas de trabajo. Esto nos permitirá entender qué quisimos hacer tiempo atrás, seremos intuitivos para encontrar archivos/objetos, y finalmente crearemos trabajos reproducibles… Una forma práctica de administrar todos los objetos de una sesión es por medio del uso de “proyectos” de R Studio. Estructura típica de un proyecto de Rstudio. Es aconsejable ser consistente en la nomenclatura de todos los objetos generados en nuestras sesiones de trabajo (archivos, carpetas, etc.). Crear una nuevo proyecto llamado “R_intro” Crear un script “dia_1” ¿Dónde se guardaría el siguiente gráfico? En este ejemplo, usaremos una función “plot()” y un dataset “pressure” prediseñados en paquetes de carga automática al iniciar R. plot(pressure) "],["sintaxis.html", "2 Sintaxis R Calculadora Comparaciones lógicas Variables y asignaciones Funciones Tips S.O.S. Tablas resumen", " 2 Sintaxis R Calculadora 4 + 9 4 - 3 * 1 #4%1 (4 + 5 ) * 7 - (36/18)^3 Ver tablas resumen de operadores aritméticos y lógicos (al final del capítulo) Reto matemático que se volvió viral en las redes sociales* Existen dos soluciones, según método que se aplique: el PEMDAS = 1 (parenthesis &lt; exponents &lt; multiplicación &lt; division &lt; addition &lt; subtraction) y el BODMAS = 16 (Brackets &lt; Orders (Powers and Square Roots) &lt; Division &lt; Multiplication &lt; Addition &lt; Subtraction). Cómo opera R? Se puede decir que hay diferencia de estilos al programar. Se deberia tener presente que otros pueden leer tu código (optar por buenas prácticas) (3+(5*(2^2))) # difícil de leer 3 + 5 * 2 ^ 2 # si se recuerdan las reglas, todo bien 3 + 5 * (2 ^ 2) # si se olvidan algunas reglas, esto podría ayudar Comparaciones lógicas 4&gt;3 4 == 4 4 != 4 4 != 3 1 &gt;= -9 Variables y asignaciones Podemos almacenar valores en variables usando el operador de asignación &lt;-, veamos un ejemplo: x &lt;- 1/40 Esta asignación no muestra el valor, sino que lo almacena para más adelante en algo llamado “variable”. Que contiene x? x shortcut de “&lt;-” : Alt - Chequear la pestaña Environment en uno de los paneles de RStudio. Nuestra variable x se puede usar en lugar de un número en cualquier cálculo que espere un número: x &lt;- x + 1 # observen cómo RStudio actualiza/sobrescribe x en la pestaña superior derecha y &lt;- x * 2 El lado derecho de la asignación puede ser cualquier expresión de R válida. La expresión del lado derecho se evalúa por completo antes de que se realice la asignación. También es posible utilizar el operador = para la asignación x = 1/40 Esta forma es menos común entre los usuarios R (se recomienda usar &lt;-). Funciones Como dijimos, los paquetes son básicamente un conjunto de funciones generadas por los autores de los mismos pero el usuario puede crear sus propias funciones. Componentes de las funciones: nombre_funcion(argumentos) Nombre: Generalmente, el nombre es intuitivo, por ejemplo, mean es la función que calcula la media, round es la funión que redondea un número.(Como habrán notado R está en inglés) Argumentos: Un argumento es un marcador de posición. Cuando se invoca una función, se debe indicar valores a los argumentos. Los argumentos son opcionales; es decir, una función puede no contener argumentos. También los argumentos pueden tener valores por defecto. Algunos cálculos basados en funciones matemáticas. Son las mas simples, y no esta funcion no contienen argumentos. [para chequear la info de la función, solo basta con seleccionar todos sus caracteres + F1] sqrt(3) # 3^0.5 # 3^(1/2) log(10) # logaritmo natural exp(2.302585) # log(10, base=10) Funciones básicas pero con argumentos Redondeo round(4.3478) round(4.3478, digits=3) Tips 1 - No se tienen en cuenta los espacios en blanco entre palabras: podemos o no dejar espacios para que el código se pueda ordenar de forma adecuada y poder entenderse. plot( pressure ) plot(pressur e) 2 - Se distinguen las mayúsculas y minúsculas (“case sensitive”): para variables en el código, podemos crear diferentes variables con nombres iguales pero alternando mayúsculas y minúsculas. Plot(pressure) 3 - Se pueden incluir comentarios: como vimos anteriormente los comentarios se utilizan para añadir información en el código. De paso observamos que plot(pressur e) # da error # grafico press vs temp plot(pressure) 4 - El punto y coma (;) actúa como separador de comandos aún en la misma línea del script! pressure; plot(pressure) 5 - Los nombres de las variables pueden contener letras, números, guiones bajos y puntos, pero NO PUEDEN: comenzar con un número contener espacios en absoluto Cada uno adopta su propia forma para nombres largos de variables, por ej: puntos.entre.palabras guiones_bajos_entre_palabras MayúsculasMinúsculasParaSepararPalabras No importa como lo adopten, pero es aconsejable ser consistente. S.O.S. En el mismo R: ?sd; ??sd; F1 sobre la función Googlear: r generate a sequence of uppercase letters Stack Overflow en inglés / Stack Overflow en español / RStudio: comunidades altamente activas por los usuarios de R y otros lenguajes de programación. R Mailing Lists: especificas de cada área de la ciencia. ¿Cómo hacer una buena pregunta en las comunidades? Ser conciso pero gentil… Ser reproducible: su código debe correr en cualquier máquina. La comunidad no irá a ayudarle si no pueden reproducir su error (detallar paquetes y versión de R en caso necesario) Tablas resumen Table 2.1: Operadores aritméticos Operador Detalle x + y Suma de x e y x - y Resta de x menos y x * y Multiplicación x / y División de x por y x %/% y Parte entera de la división de x por y x %% y Resto de la división de x por y x ^ y x elevado a y-ésima potencia (equivalente a **) Table 2.2: Operadores lógicos Operador Prueba.lógica x &lt; y x menor que y? x &lt;= y x menor o igual que y? x &gt; y x mayor que y? x &gt;= y x mayor o igual que y? x == y x igual que y? x != y x diferente que y? Table 2.3: Funciones matemáticas Operador Detalle sqrt(x) raiz de x exp(y) exponencial de y log(x) logaritmo natural de x = ln log10(x) logaritmo base 10 de x sum(x) suma todos los elementos de x prod(x) producto de todos los elementos de x round(x, n) redondea x a n-digitos Table 2.4: Algunos atajos comúnmente usados Teclas Detalle Alt+Shift+K panel de todos los atajos Ctrl+Z / Ctrl+Shift+Z undo/redo Alt+ - &lt;- Ctrl+r corre la línea/bloque completa de código Ctrl+l limpia la consola Ctrl+Shift+c silencia la línea de código Ctrl+Shift+d duplica la línea de código Ctrl+i indexa el bloque de código Ver todos los atajos en R Studio: situandose en la consola tipear simultanemante Ctrl | Shift | k "],["tipos-de-datos.html", "3 Tipos de datos 3.1 Vectores Caracter Lógicos Fechas 3.2 Datos faltantes 3.3 Factores 3.4 Secuencias 3.5 Números aleatorios 3.6 Valores especiales", " 3 Tipos de datos En términos genéricos, todos los elementos que maneja R se consideran objetos: un valor numérico, un vector, una función, una base de datos, un gráfico, todos son objetos. Uno de los típicos errores que se nos presenta al usar R es el mal uso de las distintas clases de objetos que manipulamos en nuestras sesiones de trabajo. Para un procesamiento correcto, un lenguaje de programación debe saber qué se puede y qué no se puede hacer con un valor en particular. Por ejemplo, no se pueden hacer operaciones matemáticas con las palabras “hola” y “mundo”. Del mismo modo, no puede cambiar los números 1 y -34.5 de minúsculas a mayúsculas. Debido a esto, R tiene una característica llamada tipos de datos. Principales tipos de datos que vamos a usar: Clase Ejemplo numérico 12.3, 5, 999 caracter hola, JUAN lógica TRUE, FALSE fecha 2021-05-06 3.1 Vectores La unidad básica de datos en R es un vector, los cuales pueden ser de diferentes clases. Los que más usaremos son las siguientes clases. vector &lt;- c(Concatenación, de, elementos, atómicos) raices_largo &lt;- c(8.5, 9, 11) Hay muchas funciones que nos permiten inspeccionar los datos. Una muy versatil es str() str(raices_largo) length(raices_largo) Supongamos que “raices_largo” es una muestra de la variable largo de raiz de trigo en cm y nos interesaria algunas métricas summary(raices_largo) …descomponiendo ´summary´ # Medidas de posición mean(raices_largo) median(raices_largo) quantile(raices_largo, 0.25) # Medidas de dispersión min(raices_largo) max(raices_largo) range(raices_largo) Al tratarse de números podemos hacer operaciones estadísticas o matemáticas como: var(raices_largo) sd(raices_largo) sqrt(var(raices_largo)) raices_largo - 1 sum(raices_largo) cumsum(raices_largo) Caracter Almacena valores de “caracteres” o “cadenas” (en inglés “string”): pueden contener letras, números y símbolos. La forma más sencilla de indicar que un valor es de tipo carácter es colocar el valor entre comillas simples o dobles. vec_car &lt;- c(&quot;Hola mundo&quot;, &quot;2022-20-04&quot;, &#39;2022&#39;) str(vec_car) Lógicos El tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores: falso o verdadero vec_logi &lt;- c(FALSE, TRUE, F, T) # logi &lt;- false str(vec_logi) Fechas El formato default es yyyy-mm-dd vec_fechas &lt;- as.Date(c(&quot;2007-06-22&quot;, &quot;2004-02-13&quot;)) str(vec_fechas) vec_fechas - 1 Nosotros comunmente usamos ‘dd/mm/yyyy’? debemos convertir: vec_fechas2 &lt;- c(&quot;01/06/2020&quot;, &quot;31/12/2020&quot;) str(vec_fechas2) # son caracteres! vec_fechas3 &lt;- as.Date(vec_fechas2, &quot;%d/%m/%Y&quot;) # con paquete base str(vec_fechas3) vec_fechas4 &lt;- lubridate::dmy(vec_fechas2) # con lubridate! str(vec_fechas4) diff(vec_fechas4) Forzando las clases explícitamente raices_car &lt;- as.character(raices_largo) str(raices_car) vec_logi2 &lt;- as.logical(c(0,1)) vec_logi2 vec_logi_num &lt;- as.numeric(vec_logi) vec_logi_num Existe una jerarquia a la hora de R tener que decidir de qué tipo de vector se trata (“piedra, papel o tijera”) y1 &lt;- c(1.7, &quot;a&quot;) ## character str(y1) y2 &lt;- c(TRUE, &quot;a&quot;) ## character str(y2) y3 &lt;- c(TRUE, 0, 10) ## numeric str(y3) 3.2 Datos faltantes Se representan con un NA, para cualquier tipo de datos vec_num &lt;- c(1, 5, NA) str(vec_num) length(vec_num) 3.3 Factores En R las variables categóricas se almacenan como factores tanto sea para vectores que contienen caracteres o numéros. Uno de los usos más importantes de los factores es en el modelado estadístico, asumiendo un rol de variable categorica, diferente de las variables contínuas. Claro ejemplo de factores son los tratamientos, por ej: genotipos, bloques, etc. A diferencia de los vectores vistos anteriormente, todo factor tiene sus niveles (levels), que por default se ordenan alfabéticamente. geno &lt;- c(&quot;control&quot;, &quot;B35&quot;, &quot;A12&quot;, &quot;control&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;control&quot;) str(geno) levels(geno) geno_f &lt;- factor(geno) str(geno_f) 3.4 Secuencias Numéricas 1:7 seq(from = 0, to = 20, #by=2) # length=4) rep(1:3, times=3) # , each=3 Letras LETTERS rep(c(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;), times=3) # , each=3 Fechas seq(as.Date(&quot;2015-01-15&quot;), as.Date(&quot;2015-12-15&quot;), &quot;1 month&quot;) 3.5 Números aleatorios La generación de números aleatorios es en muchas ocasiones un requerimiento esencial en investigación científica. Proceder de este modo puede reducir cualquier sesgo generado por nuestra persona a la hora de seleccionar una muestra, o aplicar un tratamiento a una unidad experimental. Generar números enteros de modo aleatorio de una muestra determinada sample() set.seed(123) sample(1:30, size=10, replace=F) #sin reposición Generar números aleatorios de una distribución específica de parámetros conocidos: runif() - números racionales aleatoriamente, uniformemente distribuidos en un intervalo num_unif &lt;- runif(100, min=3, max=4) hist(num_unif) rnorm() - números aleatorios, pertenecientes a una población con distribución normal, con parámetros μ y σ. num_norm &lt;- rnorm(100, mean=70, sd=5) hist(num_norm) 3.6 Valores especiales Existen valores reservados para representar datos faltantes, infinitos, e indefiniciones matemáticas. NA (Not Available) significa dato faltante/indisponible. El NA tiene una clase, o sea, pueden ser NA numeric, NA character, etc. y &lt;- c(2, 4, NA, 6) is.na(y) Calcule el promedio de y (use la ayuda de R en caso necesario)mean(y) NaN (Not a Number) es el resultado de una operación matemática inválida, ej: 0/0 y log(-1). Un NaN es un NA, pero no recíprocamente. 0/0 is.nan(0/0) is.na(0/0) NULL es el vacío de R. Es como si el objeto no existiese a = NULL a Inf (infinito). Es el resultado de operaciones matemáticas cuyo límite es infinito, es decir, es un número muy grande, por ejemplo, 1/0 o 10^310. Acepta signo negativo -Inf. 1/0 1/Inf "],["estructura-de-datos.html", "4 Estructura de datos Data frames", " 4 Estructura de datos Data frames Conjunto de variables (columnas), de cualquier tipo de datos (categóricas, lógicas, fechas) Un dataframe es completo con dimensiones n_fila x p_columna, donde: 1- Cada fila debe contener toda la info de la unidad experimental que se está evaluando 2- Cada columna representa una variable (descriptiva o respuesta) 3- Cada celda debe tener su observación (en caso de faltar el dato será un NA) Como hemos visto, hay data frames contenidos en paquetes de inico automático. Un ejemplo muy usado, que está en el paquete base es el dataset “iris”. iris # ya activo desde inicio de sesión por default ?iris # F1 View(iris) # F2 str(iris) Explore el dataset iris con las siguientes funciones y comente sus resultados: dim(); head(); tail(); names(); str(); summary() str(iris) summary(iris) dim(iris) head(iris) tail(iris) names(iris) Paquetes de exploracion rapida de datasets {skimr} library(skimr) skim(iris) Creacion de dataframes a partir de vectores x &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) y &lt;- c(1, 3, NA) dat &lt;- data.frame(x,y) dat str(dat) dat$ library(tibble) dat &lt;- tribble( ~x, ~y, &quot;A&quot;, 1, &quot;B&quot;, 3, &quot;C&quot;, NA ) Otras estructuras de datos Listas Son vectores de objetos de cualquier clase x &lt;- list(a = 1:5, b = c(&quot;a&quot;, &quot;b&quot;), c = TRUE, d=dat) x (Más info de subsetting elementos de una lista aquí) x$a # x[1] # #sum(x[1]) x[[1]] # sum(x[[1]]) x[&quot;c&quot;] # Matrices Admiten un unico tipo de dato y carecen de nombre de columna. Al igual que los dataframes tienen dimensiones fila x columna. Indicamos el número de filas con el argumento nrow y con ncol el número de columnas; luego indicamos qué valores forman la matriz (del 1 al 9), y le hemos pedido a R que use esos valores para rellenar la matriz A por filas con byrow=TRUE. La matriz A así construida es: A &lt;- matrix(nrow=3, ncol=3, c(1,2,3,4,5,6,7,8,9), byrow=TRUE) A "],["visualización.html", "5 Visualización ggplot 5.1 Ambas variables contínuas 5.2 Comparación de niveles de factores", " 5 Visualización ggplot El paquete ggplot2 tiene una flexibilidad tal que permite generar rápidamente gráficos exploratorios así como crear figuras complejas, detalladas, de alta calidad (con fines de publicaciones científicas, por ej). Tiene una gramática propia: “suma de capas” Las capas no tienen un orden estricto salvo la primera que debe ser ggplot(). Un mismo gráfico acepta tomar información de distintos datasets Las capas se van agregando con un simbolo + Las capas básicas son: data ggplot: inicializa un objeto grafico de ggplot aesthetics aes: “Algo que se puede ver” Dentro de la capa aes debemos indicar que a que variable se atribuyen los diferentes atributos: mapeo de variables (ejes x= e y=) color exterior de los objetos o de las líneas (col) color de relleno (fill) forma de los puntos (shape) tipo de línea (linetype) tamaño de los puntos (size) geometriasgeom_: formas geométricas para representar las observaciones (dan el nombre al tipo de gráfico: grafico de dispersion, boxplot, histograma, etc…) geom_point() geom_smooth() geom_boxplot() lista de “geoms” facetasfacet_: “paneles de compartimentalización” de un mismo gráfico facet_wrap(): paneles contiguos facets_grid(): paneles tipo grilla Ejemplo de visualización con iris library(tidyverse) 5.1 Ambas variables contínuas ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length) geoms Objetos geométricos. Son la representación visual de las observaciones. En general los que le dan el nombre al tipo de gráfico. La lista de “geoms” aumenta día a día. ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point() ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point(aes(color = Species)) ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point(aes(color = Species))+ geom_smooth() ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length, color = Species) + geom_point()+ geom_smooth() facets Las facetas o “facets” permiten dividir el mismo gráfico en múltiples paneles asociados a los niveles de un factor. ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point()+ geom_smooth(method = &quot;lm&quot;)+ facet_wrap(~Species) theme Los temas (theme) son un conjunto de opciones predefinidas sobre la apariencia de los objetos en ggplot. El tema por defecto del ggplot dibuja el gráfico sobre un fondo gris. Podemos cambiarlo a blanco y negro añadiendo el comando theme_bw(). ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point()+ geom_smooth(method = &quot;lm&quot;)+ facet_wrap(~Species) + theme_bw() 5.1.1 Como guardar los gráficos ggsave(last_plot(), file=&quot;plots/iris_smooth.tiff&quot;, w=80, h=60, units=&quot;mm&quot;, dpi=300) 5.2 Comparación de niveles de factores Los gráficos de barra, ampliamente usados en publicaciones científicas, son cada vez más criticados por “ocultar” la naturaleza de las observaciones (Drummond and Vowler 2011; Weissgerber 2015) De (Drummond and Vowler 2011): Fig 1. Many different datasets can lead to the same bar graph. The full data may suggest different conclusions from the summary statistics. The means and SEs for the four example datasets shown in Panels B–E are all within 0.5 units of the means and SEs shown in the bar graph (Panel A). p-values were calculated in R (version 3.0.3) using an unpaired t-test, an unpaired t-test with Welch’s correction for unequal variances, or a Wilcoxon rank sum test. - In Panel B, the distribution in both groups appears symmetric. Although the data suggest a small difference between groups, there is substantial overlap between groups. - In Panel C, the apparent difference between groups is driven by an outlier. - Panel D suggests a possible bimodal distribution. Additional data are needed to confirm that the distribution is bimodal and to determine whether this effect is explained by a covariate. - In Panel E, the smaller range of values in group two may simply be due to the fact that there are only four observations. Additional data for group two would be needed to determine whether the groups are actually different. A continuación presentamos algunas opciones gráficas que surgen de la combinación de medidas de posición y de dispersión. #Aprovechamos para customizar el `theme` a nuestro gusto y agregar algunos detalles: p0 &lt;- ggplot(iris) + aes(x = Species, y = Petal.Length)+ labs(x = &quot;Iris species&quot;, y =&quot;Sepal length (cm)&quot;) + theme_light(base_size = 10) p0 5.2.1 Observaciones + media / mediana p1 &lt;- p0 + geom_point(shape = 1, alpha=0.2)+ stat_summary(fun= mean, #median fun.min= mean, fun.max = mean, geom = &quot;point&quot;, size = 2)+ ggtitle(&quot;Observaciones (points) &amp; media&quot;) p1 p2 &lt;- p0 + geom_jitter(width = 0.2, alpha=0.2)+ stat_summary(fun = mean, #median fun.min= mean, fun.max = mean, geom = &quot;crossbar&quot;, size = 0.5)+ ggtitle(&quot;Observaciones (jitter) &amp; media&quot;) p2 5.2.2 Barplot + SE p3 &lt;-p0 + # geom_bar(stat=&quot;identity&quot;) + stat_summary(fun=mean, position=position_dodge(width=0.95),geom=&quot;bar&quot;, colour=&quot;black&quot;,fill=&quot;grey90&quot;)+ stat_summary(fun.data=mean_cl_normal, geom=&quot;errorbar&quot;, width=0.2) + ggtitle(&quot;Barplot &amp; SEM&quot;) # geom_text(data= let, aes(label = M, x= trt, y=1, hjust=0.5),size = 4) p3 5.2.3 Box-plot p4 &lt;-p0 + geom_boxplot(fill = &quot;grey90&quot;) + ggtitle(&quot;Boxplot &amp; mean&quot;) p4 5.2.4 Violin plot p5 &lt;-p0 + geom_violin(trim=FALSE,fill = &quot;grey90&quot;)+ ggtitle(&quot;Violin plot&quot;) p5 5.2.5 Media &amp; dispersión p6 &lt;-p0 + stat_summary(fun=&quot;mean&quot;, geom=&quot;point&quot;, size=2)+ stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width=0.2)+ stat_summary(fun.data= mean_sdl, geom = &quot;errorbar&quot;, color=&quot;red&quot;, width=0.2)+ stat_summary(fun.data = mean_cl_boot, geom = &quot;errorbar&quot;, color=&quot;blue&quot;, width=0.2)+ ggtitle(&quot;Media + SE (negro) / SD (rojo) / 95% CI (negro)&quot;) p6 library(cowplot) plot_grid(p1, p2, p3, p4, p5, p6, ncol = 3, nrow = 2) Si deseamos explorar las distribuciones de las variables podemos optar por un histograma o por diagramas de densidad. cowplot::plot_grid( iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_histogram()+ guides(fill=FALSE) , iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_density(alpha=0.7) , align=&quot;h&quot; ) La gran comunidad de usuarios de R disponibiliza sus creaciones e incluso trabaja en extensiones que amplían la potencialidad de sus paquetes. Se podría afirmar que no hay límites para la creación. Digamos, que no importa el “¿cómo?” si no el “¿qué?” Algunas pruebas de ello son los siguientes links: The R Graph Gallery Top 50 plots Extensiones de ggplot Fundamentals of Data Visualization "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
