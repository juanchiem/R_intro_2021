[["index.html", "Exploración y manipulación de datos con R Motivación", " Exploración y manipulación de datos con R Motivación “Una de las cosas más importantes que puedes hacer es dedicar un tiempo para aprender un lenguaje de programación. Aprender a programar es como aprender otro idioma: requiere tiempo y entrenamiento, y no hay resultados prácticos inmediatos. Pero si superas esa primera subida empinada de la curva de aprendizaje, las ganancias como científico son enormes. Programar no sólo te liberará de la camisa de fuerza de los softwares estadísticos cerrados, sino que también agudizará tus habilidades analíticas y ampliará los horizontes de modelado ecológico y estadístico.” ~ Adaptación de (Ellison and Gotelli 2004) ~ ¿Por qué R? (R Core Team 2017) Software libre - multiplataforma Aprender un lenguaje de programación: ejercicio mental/lógica (Mayor aprovechamiento de otros cursos específicos) (Si quieren aprender a fondo matemática, aprendan programación, si quieren aprender a fondo biología, aprendan programación…) Amplia gama de paquetes específicos Gran flexibilidad y elegancia de los gráficos Popularidad - Comunidad activa y creciente dispuesta a ayudar (aprendemos a usar terminos técnicos de data science en inglés) Programar ya no es sólo computación (CV/relevant skills) "],["objetivos.html", "Objetivos", " Objetivos Proveer en 3 semanas de curso un pantallazo de las herramientas que pueden optimizar la labor cotidiana a lo largo de la vida como recolector/analista de datos. ~ Adaptación de “R for Data Science” (Wickham and Grolemund 2016) ~ Acompañar la primer fase empinada de la curva de aprendizaje de un nuevo lenguaje, que a la larga redituará en multiples beneficios tanto profesionales como personales. Brindar un sistema flexible de aprendizaje en cuanto a los horarios de cada uno y, en caso de ser necesario, un soporte personalizado para llegar a la meta de que “todos salgan andando con R”. Importante: no es un curso de estadística entendemos la programación como un simple medio para optimizar nuestra labor cotidiana (no como un fin mismo), al final del día seguimos siendo fitopatólogos, veterinarios, bioquímicos, etc. maximizaremos la adopción de la sintaxis tidyverse "],["sobre-el-curso.html", "Sobre el curso", " Sobre el curso Se disponibiliza de este manual web con los códigos que se irán reproduciendo en las clases teoricas para la reproducibilidad en las computadoras personales. Para ello debe cliquearse el icono en el angulo superior derecho de los bloques grises y asi se copia todo su contenido. Códigos en marcos azules son material suplementario para quienes quieran profundizar en horario extra-clase. "],["config.html", "1 Configuraciones básicas Paquetes de R Proyectos de RStudio", " 1 Configuraciones básicas Instalación de programas 1° R 2° R Studio (bajar la versión Free) RStudio es un entorno de desarrollo integrado (IDE) para el lenguaje de programación R, o sea es la interface por medio de la cual se ejecutan acciones en R. Configuraciones iniciales (sugeridas). Dirigirse a la sección “Tools/Global options” Paquetes de R Un paquete es una colección de funciones, datos y código R que se almacenan en una carpeta conforme a una estructura bien definida, fácilmente accesible para R. Un repositorio es un lugar donde se alojan los paquetes para que pueda instalarlos desde él. Los repositorios mas populares son: CRAN: repositorio oficial. Es una red de servidores web mantenida por la comunidad R en todo el mundo. El Core Team de R lo coordina, y para que un paquete se publique aquí, debe pasar varias pruebas que aseguren el cumplimiento de las políticas de CRAN. GITHUB: probablemente el repositorio más popular para proyectos particulares de código abierto. No es específico de R (sin proceso de revisión asociado). Bioconductor: repositorio destinado a software de código abierto para bioinformática. Como CRAN, tiene sus propios procesos de presentación y revisión, y su comunidad es muy activa y tiene varias conferencias y reuniones al año. La simple instalación de R trae consigo múltiples paquetes que permiten un funcionamiento básico de importación de datos, ajuste y evaluación de modelos estadísticos y representaciones gráficas. Sin embargo, la enorme potencia de R deriva de su capacidad de incorporar nuevas funciones generadas por su gran comunidad de usuarios En la web de R se puede consultar la lista de paquetes disponibles, y en la sección Task Views se puede consultar los mismos ordenados por áreas de aplicación. Links para exploración o chequeo de novedades de paquetes: Rdocumentation METACRAN r weekly r-bloggers revolution analytics RStudio blog Existen varias vias de instalación de paquetes: Via consola: install.packages(\"nombre_del_paquete\") O simplemente en el panel de paquetes. Una vez instalado, hay que cargar los paquetes que contienen las funciones que vayamos a usar en cada sesión library(nombre-del-paquete) instale el paquete pacman y activelo Proyectos de RStudio Varios tipos de archivos serán creados y usados durante una sesión de R: datos crudos (hojas de cálculo) - datos manipulados scripts gráficos reportes de resultados Una análisis debe poder ser retomado en cualquier momento pudiendo darse por concluída cuando el trabajo es publicado. Hasta entonces debemos tener rápido acceso a todos los objetos creados en sesiones anteriores. Para ello debemos manejarnos siempre bajo buenas prácticas de trabajo. Esto nos permitirá entender qué quisimos hacer tiempo atrás, seremos intuitivos para encontrar archivos/objetos, y finalmente crearemos trabajos reproducibles… Una forma práctica de administrar todos los objetos de una sesión es por medio del uso de “proyectos” de R Studio. Estructura típica de un proyecto de Rstudio. Es aconsejable ser consistente en la nomenclatura de todos los objetos generados en nuestras sesiones de trabajo (archivos, carpetas, etc.). Crear una nuevo proyecto llamado “R_intro” Crear un script “dia_1” ¿Dónde se guardaría el siguiente gráfico? En este ejemplo, usaremos una función “plot()” y un dataset “pressure” prediseñados en paquetes de carga automática al iniciar R. plot(pressure) "],["sintaxis.html", "2 Sintaxis R Calculadora Comparaciones lógicas Variables y asignaciones Funciones Tips S.O.S. Tablas resumen", " 2 Sintaxis R Calculadora 4 + 9 4 - 3 * 1 #4%1 (4 + 5 ) * 7 - (36/18)^3 Ver tablas resumen de operadores aritméticos y lógicos (al final del capítulo) Reto matemático que se volvió viral en las redes sociales* Existen dos soluciones, según método que se aplique: el PEMDAS = 1 (parenthesis &lt; exponents &lt; multiplicación &lt; division &lt; addition &lt; subtraction) y el BODMAS = 16 (Brackets &lt; Orders (Powers and Square Roots) &lt; Division &lt; Multiplication &lt; Addition &lt; Subtraction). Cómo opera R? Se puede decir que hay diferencia de estilos al programar. Se deberia tener presente que otros pueden leer tu código (optar por buenas prácticas) (3+(5*(2^2))) # difícil de leer 3 + 5 * 2 ^ 2 # si se recuerdan las reglas, todo bien 3 + 5 * (2 ^ 2) # si se olvidan algunas reglas, esto podría ayudar Comparaciones lógicas 4&gt;3 4 == 4 4 != 4 4 != 3 1 &gt;= -9 Variables y asignaciones Podemos almacenar valores en variables usando el operador de asignación &lt;-, veamos un ejemplo: x &lt;- 1/40 Esta asignación no muestra el valor, sino que lo almacena para más adelante en algo llamado “variable”. Que contiene x? x shortcut de “&lt;-” : Alt - Chequear la pestaña Environment en uno de los paneles de RStudio. Nuestra variable x se puede usar en lugar de un número en cualquier cálculo que espere un número: x &lt;- x + 1 # observen cómo RStudio actualiza/sobrescribe x en la pestaña superior derecha y &lt;- x * 2 El lado derecho de la asignación puede ser cualquier expresión de R válida. La expresión del lado derecho se evalúa por completo antes de que se realice la asignación. También es posible utilizar el operador = para la asignación x = 1/40 Esta forma es menos común entre los usuarios R (se recomienda usar &lt;-). Funciones Como dijimos, los paquetes son básicamente un conjunto de funciones generadas por los autores de los mismos pero el usuario puede crear sus propias funciones. Componentes de las funciones: nombre_funcion(argumentos) Nombre: Generalmente, el nombre es intuitivo, por ejemplo, mean es la función que calcula la media, round es la funión que redondea un número.(Como habrán notado R está en inglés) Argumentos: Un argumento es un marcador de posición. Cuando se invoca una función, se debe indicar valores a los argumentos. Los argumentos son opcionales; es decir, una función puede no contener argumentos. También los argumentos pueden tener valores por defecto. Algunos cálculos basados en funciones matemáticas. Son las mas simples, y no esta funcion no contienen argumentos. [para chequear la info de la función, solo basta con seleccionar todos sus caracteres + F1] sqrt(3) # 3^0.5 # 3^(1/2) log(10) # logaritmo natural exp(2.302585) # log(10, base=10) Funciones básicas pero con argumentos Redondeo round(4.3478) round(4.3478, digits=3) Tips 1 - No se tienen en cuenta los espacios en blanco entre palabras: podemos o no dejar espacios para que el código se pueda ordenar de forma adecuada y poder entenderse. plot( pressure ) plot(pressur e) 2 - Se distinguen las mayúsculas y minúsculas (“case sensitive”): para variables en el código, podemos crear diferentes variables con nombres iguales pero alternando mayúsculas y minúsculas. Plot(pressure) 3 - Se pueden incluir comentarios: como vimos anteriormente los comentarios se utilizan para añadir información en el código. De paso observamos que plot(pressur e) # da error # grafico press vs temp plot(pressure) 4 - El punto y coma (;) actúa como separador de comandos aún en la misma línea del script! pressure; plot(pressure) 5 - Los nombres de las variables pueden contener letras, números, guiones bajos y puntos, pero NO PUEDEN: comenzar con un número contener espacios en absoluto Cada uno adopta su propia forma para nombres largos de variables, por ej: puntos.entre.palabras guiones_bajos_entre_palabras MayúsculasMinúsculasParaSepararPalabras No importa como lo adopten, pero es aconsejable ser consistente. S.O.S. En el mismo R: ?sd; ??sd; F1 sobre la función Googlear: r generate a sequence of uppercase letters Stack Overflow en inglés / Stack Overflow en español / RStudio: comunidades altamente activas por los usuarios de R y otros lenguajes de programación. R Mailing Lists: especificas de cada área de la ciencia. ¿Cómo hacer una buena pregunta en las comunidades? Ser conciso pero gentil… Ser reproducible: su código debe correr en cualquier máquina. La comunidad no irá a ayudarle si no pueden reproducir su error (detallar paquetes y versión de R en caso necesario) Tablas resumen Table 2.1: Operadores aritméticos Operador Detalle x + y Suma de x e y x - y Resta de x menos y x * y Multiplicación x / y División de x por y x %/% y Parte entera de la división de x por y x %% y Resto de la división de x por y x ^ y x elevado a y-ésima potencia (equivalente a **) Table 2.2: Operadores lógicos Operador Prueba.lógica x &lt; y x menor que y? x &lt;= y x menor o igual que y? x &gt; y x mayor que y? x &gt;= y x mayor o igual que y? x == y x igual que y? x != y x diferente que y? Table 2.3: Funciones matemáticas Operador Detalle sqrt(x) raiz de x exp(y) exponencial de y log(x) logaritmo natural de x = ln log10(x) logaritmo base 10 de x sum(x) suma todos los elementos de x prod(x) producto de todos los elementos de x round(x, n) redondea x a n-digitos Table 2.4: Algunos atajos comúnmente usados Teclas Detalle Alt+Shift+K panel de todos los atajos Ctrl+Z / Ctrl+Shift+Z undo/redo Alt+ - &lt;- Ctrl+r corre la línea/bloque completa de código Ctrl+l limpia la consola Ctrl+Shift+c silencia la línea de código Ctrl+Shift+d duplica la línea de código Ctrl+i indexa el bloque de código Ver todos los atajos en R Studio: situandose en la consola tipear simultanemante Ctrl | Shift | k "],["tipos-de-datos.html", "3 Tipos de datos 3.1 Vectores Caracter Lógicos Fechas 3.2 Datos faltantes 3.3 Factores 3.4 Secuencias 3.5 Números aleatorios 3.6 Valores especiales", " 3 Tipos de datos En términos genéricos, todos los elementos que maneja R se consideran objetos: un valor numérico, un vector, una función, una base de datos, un gráfico, todos son objetos. Uno de los típicos errores que se nos presenta al usar R es el mal uso de las distintas clases de objetos que manipulamos en nuestras sesiones de trabajo. Para un procesamiento correcto, un lenguaje de programación debe saber qué se puede y qué no se puede hacer con un valor en particular. Por ejemplo, no se pueden hacer operaciones matemáticas con las palabras “hola” y “mundo”. Del mismo modo, no puede cambiar los números 1 y -34.5 de minúsculas a mayúsculas. Debido a esto, R tiene una característica llamada tipos de datos. Principales tipos de datos que vamos a usar: Clase Ejemplo numérico 12.3, 5, 999 caracter hola, JUAN lógica TRUE, FALSE fecha 2021-05-06 3.1 Vectores La unidad básica de datos en R es un vector, los cuales pueden ser de diferentes clases. Los que más usaremos son las siguientes clases. vector &lt;- c(Concatenación, de, elementos, atómicos) raices_largo &lt;- c(8.5, 9, 11) Hay muchas funciones que nos permiten inspeccionar los datos. Una muy versatil es str() str(raices_largo) length(raices_largo) Supongamos que “raices_largo” es una muestra de la variable largo de raiz de trigo en cm y nos interesaria algunas métricas summary(raices_largo) …descomponiendo ´summary´ # Medidas de posición mean(raices_largo) median(raices_largo) quantile(raices_largo, 0.25) # Medidas de dispersión min(raices_largo) max(raices_largo) range(raices_largo) Al tratarse de números podemos hacer operaciones estadísticas o matemáticas como: var(raices_largo) sd(raices_largo) sqrt(var(raices_largo)) raices_largo - 1 sum(raices_largo) cumsum(raices_largo) Caracter Almacena valores de “caracteres” o “cadenas” (en inglés “string”): pueden contener letras, números y símbolos. La forma más sencilla de indicar que un valor es de tipo carácter es colocar el valor entre comillas simples o dobles. vec_car &lt;- c(&quot;Hola mundo&quot;, &quot;2022-20-04&quot;, &#39;2022&#39;) str(vec_car) Lógicos El tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores: falso o verdadero vec_logi &lt;- c(FALSE, TRUE, F, T) # logi &lt;- false str(vec_logi) Fechas El formato default es yyyy-mm-dd vec_fechas &lt;- as.Date(c(&quot;2007-06-22&quot;, &quot;2004-02-13&quot;)) str(vec_fechas) vec_fechas - 1 Nosotros comunmente usamos ‘dd/mm/yyyy’? debemos convertir: vec_fechas2 &lt;- c(&quot;01/06/2020&quot;, &quot;31/12/2020&quot;) str(vec_fechas2) # son caracteres! vec_fechas3 &lt;- as.Date(vec_fechas2, &quot;%d/%m/%Y&quot;) # con paquete base str(vec_fechas3) vec_fechas4 &lt;- lubridate::dmy(vec_fechas2) # con lubridate! str(vec_fechas4) diff(vec_fechas4) Forzando las clases explícitamente raices_car &lt;- as.character(raices_largo) str(raices_car) vec_logi2 &lt;- as.logical(c(0,1)) vec_logi2 vec_logi_num &lt;- as.numeric(vec_logi) vec_logi_num Existe una jerarquia a la hora de R tener que decidir de qué tipo de vector se trata (“piedra, papel o tijera”) y1 &lt;- c(1.7, &quot;a&quot;) ## character str(y1) y2 &lt;- c(TRUE, &quot;a&quot;) ## character str(y2) y3 &lt;- c(TRUE, 0, 10) ## numeric str(y3) 3.2 Datos faltantes Se representan con un NA, para cualquier tipo de datos vec_num &lt;- c(1, 5, NA) str(vec_num) length(vec_num) 3.3 Factores En R las variables categóricas se almacenan como factores tanto sea para vectores que contienen caracteres o numéros. Uno de los usos más importantes de los factores es en el modelado estadístico, asumiendo un rol de variable categorica, diferente de las variables contínuas. Claro ejemplo de factores son los tratamientos, por ej: genotipos, bloques, etc. A diferencia de los vectores vistos anteriormente, todo factor tiene sus niveles (levels), que por default se ordenan alfabéticamente. geno &lt;- c(&quot;control&quot;, &quot;B35&quot;, &quot;A12&quot;, &quot;control&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;control&quot;) str(geno) levels(geno) geno_f &lt;- factor(geno) str(geno_f) 3.4 Secuencias Numéricas 1:7 seq(from = 0, to = 20, #by=2) # length=4) rep(1:3, times=3) # , each=3 Letras LETTERS rep(c(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;), times=3) # , each=3 Fechas seq(as.Date(&quot;2015-01-15&quot;), as.Date(&quot;2015-12-15&quot;), &quot;1 month&quot;) 3.5 Números aleatorios La generación de números aleatorios es en muchas ocasiones un requerimiento esencial en investigación científica. Proceder de este modo puede reducir cualquier sesgo generado por nuestra persona a la hora de seleccionar una muestra, o aplicar un tratamiento a una unidad experimental. Generar números enteros de modo aleatorio de una muestra determinada sample() set.seed(123) sample(1:30, size=10, replace=F) #sin reposición Generar números aleatorios de una distribución específica de parámetros conocidos: runif() - números racionales aleatoriamente, uniformemente distribuidos en un intervalo num_unif &lt;- runif(100, min=3, max=4) hist(num_unif) rnorm() - números aleatorios, pertenecientes a una población con distribución normal, con parámetros μ y σ. num_norm &lt;- rnorm(100, mean=70, sd=5) hist(num_norm) 3.6 Valores especiales Existen valores reservados para representar datos faltantes, infinitos, e indefiniciones matemáticas. NA (Not Available) significa dato faltante/indisponible. El NA tiene una clase, o sea, pueden ser NA numeric, NA character, etc. y &lt;- c(2, 4, NA, 6) is.na(y) Calcule el promedio de y (use la ayuda de R en caso necesario)mean(y) NaN (Not a Number) es el resultado de una operación matemática inválida, ej: 0/0 y log(-1). Un NaN es un NA, pero no recíprocamente. 0/0 is.nan(0/0) is.na(0/0) NULL es el vacío de R. Es como si el objeto no existiese a = NULL a Inf (infinito). Es el resultado de operaciones matemáticas cuyo límite es infinito, es decir, es un número muy grande, por ejemplo, 1/0 o 10^310. Acepta signo negativo -Inf. 1/0 1/Inf "],["estructura-de-datos.html", "4 Estructura de datos Data frames", " 4 Estructura de datos Data frames Conjunto de variables (columnas), de cualquier tipo de datos (categóricas, lógicas, fechas) Un dataframe es completo con dimensiones n_fila x p_columna, donde: 1- Cada fila debe contener toda la info de la unidad experimental que se está evaluando 2- Cada columna representa una variable (descriptiva o respuesta) 3- Cada celda debe tener su observación (en caso de faltar el dato será un NA) Como hemos visto, hay data frames contenidos en paquetes de inico automático. Un ejemplo muy usado, que está en el paquete base es el dataset “iris”. iris # ya activo desde inicio de sesión por default ?iris # F1 View(iris) # F2 str(iris) Explore el dataset iris con las siguientes funciones y comente sus resultados: dim(); head(); tail(); names(); str(); summary() str(iris) summary(iris) dim(iris) head(iris) tail(iris) names(iris) Paquetes de exploracion rapida de datasets {skimr} library(skimr) skim(iris) Creacion de dataframes a partir de vectores x &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) y &lt;- c(1, 3, NA) dat &lt;- data.frame(x,y) dat str(dat) dat$ library(tibble) dat &lt;- tribble( ~x, ~y, &quot;A&quot;, 1, &quot;B&quot;, 3, &quot;C&quot;, NA ) Otras estructuras de datos Listas Son vectores de objetos de cualquier clase x &lt;- list(a = 1:5, b = c(&quot;a&quot;, &quot;b&quot;), c = TRUE, d=dat) x (Más info de subsetting elementos de una lista aquí) x$a # x[1] # #sum(x[1]) x[[1]] # sum(x[[1]]) x[&quot;c&quot;] # Matrices Admiten un unico tipo de dato y carecen de nombre de columna. Al igual que los dataframes tienen dimensiones fila x columna. Indicamos el número de filas con el argumento nrow y con ncol el número de columnas; luego indicamos qué valores forman la matriz (del 1 al 9), y le hemos pedido a R que use esos valores para rellenar la matriz A por filas con byrow=TRUE. La matriz A así construida es: A &lt;- matrix(nrow=3, ncol=3, c(1,2,3,4,5,6,7,8,9), byrow=TRUE) A "],["tidyverse.html", "Tidyverse", " Tidyverse "],["visualización.html", "5 Visualización ggplot 5.1 Ambas variables contínuas 5.2 ggsave 5.3 Comparación de niveles de factores", " 5 Visualización ggplot El paquete ggplot2 tiene una flexibilidad tal que permite generar rápidamente gráficos exploratorios así como crear figuras complejas, detalladas, de alta calidad (con fines de publicaciones científicas, por ej). Tiene una gramática propia: “suma de capas” Las capas no tienen un orden estricto salvo la primera que debe ser ggplot(). Un mismo gráfico acepta tomar información de distintos datasets Las capas se van agregando con un simbolo + Las capas básicas son: data ggplot: inicializa un objeto grafico de ggplot aesthetics aes: “Algo que se puede ver” Dentro de la capa aes debemos indicar que a que variable se atribuyen los diferentes atributos: mapeo de variables (ejes x= e y=) color exterior de los objetos o de las líneas (col) color de relleno (fill) forma de los puntos (shape) tipo de línea (linetype) tamaño de los puntos (size) geometriasgeom_: formas geométricas para representar las observaciones (dan el nombre al tipo de gráfico: grafico de dispersion, boxplot, histograma, etc…) geom_point() geom_smooth() geom_boxplot() lista de “geoms” facetasfacet_: “paneles de compartimentalización” de un mismo gráfico facet_wrap(): paneles contiguos facets_grid(): paneles tipo grilla Ejemplo de visualización con iris library(tidyverse) 5.1 Ambas variables contínuas ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length) geoms Objetos geométricos. Son la representación visual de las observaciones. En general los que le dan el nombre al tipo de gráfico. La lista de “geoms” aumenta día a día. ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point() ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point(aes(color = Species)) ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point(aes(color = Species))+ geom_smooth() ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length, color = Species) + geom_point()+ geom_smooth() facets Las facetas o “facets” permiten dividir el mismo gráfico en múltiples paneles asociados a los niveles de un factor. ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point()+ geom_smooth(method = &quot;lm&quot;)+ facet_wrap(~Species) theme Los temas (theme) son un conjunto de opciones predefinidas sobre la apariencia de los objetos en ggplot. El tema por defecto del ggplot dibuja el gráfico sobre un fondo gris. Podemos cambiarlo a blanco y negro añadiendo el comando theme_bw(). ggplot(iris) + aes(x = Sepal.Length, y = Petal.Length)+ geom_point()+ geom_smooth(method = &quot;lm&quot;)+ facet_wrap(~Species) + theme_bw() 5.2 ggsave ggsave(last_plot(), file=&quot;plots/iris_smooth.tiff&quot;, w=80, h=60, units=&quot;mm&quot;, dpi=300) 5.3 Comparación de niveles de factores Los gráficos de barra, ampliamente usados en publicaciones científicas, son cada vez más criticados por “ocultar” la naturaleza de las observaciones (Drummond and Vowler 2011; Weissgerber 2015) De (Drummond and Vowler 2011): Fig 1. Many different datasets can lead to the same bar graph. The full data may suggest different conclusions from the summary statistics. The means and SEs for the four example datasets shown in Panels B–E are all within 0.5 units of the means and SEs shown in the bar graph (Panel A). p-values were calculated in R (version 3.0.3) using an unpaired t-test, an unpaired t-test with Welch’s correction for unequal variances, or a Wilcoxon rank sum test. - In Panel B, the distribution in both groups appears symmetric. Although the data suggest a small difference between groups, there is substantial overlap between groups. - In Panel C, the apparent difference between groups is driven by an outlier. - Panel D suggests a possible bimodal distribution. Additional data are needed to confirm that the distribution is bimodal and to determine whether this effect is explained by a covariate. - In Panel E, the smaller range of values in group two may simply be due to the fact that there are only four observations. Additional data for group two would be needed to determine whether the groups are actually different. A continuación presentamos algunas opciones gráficas que surgen de la combinación de medidas de posición y de dispersión. #Aprovechamos para customizar el `theme` a nuestro gusto y agregar algunos detalles: p0 &lt;- ggplot(iris) + aes(x = Species, y = Petal.Length)+ labs(x = &quot;Iris species&quot;, y =&quot;Sepal length (cm)&quot;) + theme_light(base_size = 10) p0 5.3.1 Observaciones + media / mediana p1 &lt;- p0 + geom_point(shape = 1, alpha=0.2)+ stat_summary(fun= mean, #median fun.min= mean, fun.max = mean, geom = &quot;point&quot;, size = 2)+ ggtitle(&quot;Observaciones (points) &amp; media&quot;) p1 p2 &lt;- p0 + geom_jitter(width = 0.2, alpha=0.2)+ stat_summary(fun = mean, #median fun.min= mean, fun.max = mean, geom = &quot;crossbar&quot;, size = 0.5)+ ggtitle(&quot;Observaciones (jitter) &amp; media&quot;) p2 5.3.2 Barplot + SE p3 &lt;-p0 + # geom_bar(stat=&quot;identity&quot;) + stat_summary(fun=mean, position=position_dodge(width=0.95),geom=&quot;bar&quot;, colour=&quot;black&quot;,fill=&quot;grey90&quot;)+ stat_summary(fun.data=mean_cl_normal, geom=&quot;errorbar&quot;, width=0.2) + ggtitle(&quot;Barplot &amp; SEM&quot;) # geom_text(data= let, aes(label = M, x= trt, y=1, hjust=0.5),size = 4) p3 5.3.3 Box-plot p4 &lt;-p0 + geom_boxplot(fill = &quot;grey90&quot;) + ggtitle(&quot;Boxplot &amp; mean&quot;) p4 5.3.4 Violin plot p5 &lt;-p0 + geom_violin(trim=FALSE,fill = &quot;grey90&quot;)+ ggtitle(&quot;Violin plot&quot;) p5 5.3.5 Media &amp; dispersión p6 &lt;-p0 + stat_summary(fun=&quot;mean&quot;, geom=&quot;point&quot;, size=2)+ stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width=0.2)+ stat_summary(fun.data= mean_sdl, geom = &quot;errorbar&quot;, color=&quot;red&quot;, width=0.2)+ stat_summary(fun.data = mean_cl_boot, geom = &quot;errorbar&quot;, color=&quot;blue&quot;, width=0.2)+ ggtitle(&quot;Media + SE (negro) / SD (rojo) / 95% CI (negro)&quot;) p6 library(cowplot) plot_grid(p1, p2, p3, p4, p5, p6, ncol = 3, nrow = 2) Si deseamos explorar las distribuciones de las variables podemos optar por un histograma o por diagramas de densidad. cowplot::plot_grid( iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_histogram()+ guides(fill=FALSE) , iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_density(alpha=0.7) , align=&quot;h&quot; ) La gran comunidad de usuarios de R disponibiliza sus creaciones e incluso trabaja en extensiones que amplían la potencialidad de sus paquetes. Se podría afirmar que no hay límites para la creación. Digamos, que no importa el “¿cómo?” si no el “¿qué?” Algunas pruebas de ello son los siguientes links: The R Graph Gallery Top 50 plots Extensiones de ggplot Fundamentals of Data Visualization "],["dplyr.html", "6 {dplyr} 6.1 mutate() 6.2 select() 6.3 filter() 6.4 count() 6.5 summarise() 6.6 arrange() 6.7 {forcats} 6.8 join()", " 6 {dplyr} Recordemos la sintaxis R base x &lt;- c(1, 2, 3, 4) sqrt(sum(x)) Como sería su equivalente bajo la sintaxis de tidyverse? library(tidyverse) x %&gt;% sum %&gt;% sqrt Ya tuvimos un primer panorama de la visualización de datos con ggplot2, que es parte el “universo ordenado”. Con el avance de nuestro trabajo con R iremos entendiendo el gran maridaje que tienen los paquetes entre si. Empecemos con uno de los mas potentes paquetes del ecosistema tidyverse: Para eso importemos el dataset balcarce desde la carpeta data bce_met_raw &lt;- rio::import(&quot;data/datos_curso.xls&quot;, sheet =&quot;bce_met&quot;) str(bce_met_raw) dplyr is a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges: 6.1 mutate() Son varias las manipulaciones que podemos realizar con dplyr Agregar nuevas variables en funcion de otras pre-existentes agreguemos la temperatura media en base a la tmin y tmax bce_met0 &lt;- bce_met_raw %&gt;% mutate(tmean = (tmax + tmin) / 2) head(bce_met) Modificar variables existentes pasemos “fecha” de formato caracter a su formato correcto Acoplemos a lubridate library(lubridate) bce_met1 &lt;- bce_met0 %&gt;% mutate(date = dmy(fecha)) head(bce_met1) ya que estamos extraigamos mas columnas relacionadas a la fecha bce_met1 &lt;- bce_met1 %&gt;% mutate(month = month(date), julian = yday(date)) head(bce_met1) creamos una nueva columna en base a una condición binaria if_else bce_met1 &lt;- bce_met1 %&gt;% mutate(frost = if_else(tmin&lt;=0, TRUE, FALSE)) head(bce_met1) creamos una nueva columna en base a una condición multiple case_when bce_met2 &lt;- bce_met1 %&gt;% mutate( ambiente = case_when( tmean &lt; 10 ~ &quot;fresco&quot;, tmean &gt; 10 &amp; tmean &lt; 20 ~ &quot;templado&quot;, tmean &gt; 20 ~ &quot;calido&quot;) ) bce_met2 6.2 select() Selecciona variables basadas en sus nombres Descartemos “fecha” Opción 1 bce_met2 &lt;- bce_met1 %&gt;% select(date, month, tmean, tmax, tmin, rad, frost) head(bce_met2) Opción 2 bce_met2 &lt;- bce_met1 %&gt;% select(-fecha) head(bce_met2) Opción 3 bce_met2 &lt;- bce_met1 %&gt;% select(date, month, contains(&quot;tm&quot;), rad, frost) head(bce_met2) 6.3 filter() Filtra filas en base a alguna condición veamos que dias tuvieron heladas bce_met2 %&gt;% filter(tmin&lt;=0) bce_met2 %&gt;% filter(frost==TRUE) 6.4 count() Cuenta el numero de observaciones por grupo bce_met2 %&gt;% count(frost) se puede agregar mas niveles de agrupamiento bce_met2 %&gt;% count(month, frost) bce_met2 %&gt;% count(frost, month) 6.5 summarise() Reduce multiples valores a valores resumenes. Generalmente combinado con group_by() para cada mes: cuantos dias helaron y cual fue la temp media bce_met2 %&gt;% group_by(month) %&gt;% summarise(tmean=mean(tmean), n_frost=sum(frost)) -&gt; bce_sum bce_sum 6.6 arrange() Cambia el orden de las filas bce_sum %&gt;% arrange(n_frost) bce_sum %&gt;% arrange(-n_frost) Ya que hicimos tantas modificaciones a los datos es un buen momento para guardar en formato .Rdata save(bce_met_raw, bce_met2, bce_sum, file=&quot;data/datos_curso.Rdata&quot;) Gráfico de Temperaturas media ggplot(bce_met2) + aes(x=date, y=tmean)+ geom_line() + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;)+ theme(axis.text.x = element_text(angle=45, hjust = 1)) + labs(x=&quot;&quot;, y=&quot;Mean temperature (ºC)&quot;) + theme_bw() + theme(axis.text.x = element_text(angle=45, hjust = 1)) nos interesa visualizar los meses en que se desarrolla el trigo (de junio a diciembre) ggplot(bce_met2) + aes(x=date)+ geom_line(aes(y = tmax, col = &quot;Máxima&quot;), alpha=.5) + geom_line(aes(y = tmin, col = &quot;Mínima&quot;), alpha=.5) + scale_colour_manual(&quot;Temperatura&quot;, values = c(&quot;Media&quot; = &quot;black&quot;, &quot;Máxima&quot; = &quot;red&quot;, &quot;Mínima&quot; = &quot;blue&quot;))+ geom_point(data = bce_met2 %&gt;% filter(tmin&lt;3), aes(x=date, y=0), shape=8, col=&quot;blue&quot;) + theme_bw() + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;, limits = as.Date(c(&quot;2018-06-01&quot;, &quot;2018-31-12&quot;)))+ theme(axis.text.x = element_text(angle=45, hjust = 1)) 6.7 {forcats} El paquete {forcats} hace un aporte clave para la manipulación de los niveles de un factor. Retomemos un ejemplo de tipico de visualización con iris iris %&gt;% ggplot() + aes(x=Species, y=Sepal.Length)+ geom_boxplot(fill=&quot;gray90&quot;)+ geom_jitter()+ labs(x= &quot;Species&quot;, y=&quot;Sepal length (cm)&quot;) + theme_bw() Reordenar niveles de un factor iris %&gt;% mutate( Species= fct_relevel(Species,&quot;virginica&quot;) ) %&gt;% ggplot() + aes(x=Species, y=Sepal.Length)+ geom_boxplot(fill=&quot;gray90&quot;)+ geom_jitter()+ labs(x= &quot;Species&quot;, y=&quot;Sepal length (cm)&quot;) + theme_bw() Renombrar niveles de un factor iris %&gt;% mutate( Species= fct_recode(Species, &quot;Setosa&quot;=&quot;setosa&quot;, &quot;Versicolor&quot;=&quot;versicolor&quot;, &quot;Virginica&quot;=&quot;virginica&quot;) ) %&gt;% ggplot() + aes(x=Species, y=Sepal.Length)+ geom_boxplot(fill=&quot;gray90&quot;)+ geom_jitter()+ labs(x= &quot;Species&quot;, y=&quot;Sepal length (cm)&quot;) + theme_bw() 6.8 join() Retomemos los datos de bce_met2 que por suerte los tenemos guardados como .Rdata para un rapido retome (nos ahorramos los pasos anteriores) # paquetes que iremos a usar en esta sesion pacman::p_load(tidyverse, lubridate, rio, janitor, nasapower) # datos guardados en la sesion previa load(&quot;data/datos_curso.Rdata&quot;) Nos acaban de pasar los datos de lluvias de Balcarce en 2018 bce_lluvias_raw &lt;- rio::import(&quot;data/datos_curso.xls&quot;, sheet =&quot;bce_lluvias&quot;) seria interesante poder acoplar a nuestro dataset bce_met2 Veamos los datos meteorologicos de Balcarce: bce_met2 bce_lluvias_raw Si hacemos la misma conversion fecha a date tendriamos una columna en comun bce_lluvias &lt;- bce_lluvias_raw %&gt;% mutate(date = dmy(fecha)) %&gt;% select(-fecha) str(bce_lluvias) Ahora hagamos uso de left_join() para que matcheen las filas y se peguen la columna de lluvia a bce_met2 bce_full &lt;- bce_met2 %&gt;% left_join(bce_lluvias, by=&quot;date&quot;) str(bce_full) # veamos otra utilidad mas de mutate! bce_full &lt;- bce_met2 %&gt;% left_join(bce_lluvias, by=&quot;date&quot;) mutate(pp = replace_na(pp, 0)) str(bce_full) ggplot(bce_full) + aes(x=date)+ geom_col(aes(y = pp)) + theme_bw() + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;, limits = as.Date(c(&quot;2018-06-01&quot;, &quot;2018-31-12&quot;)))+ theme(axis.text.x = element_text(angle=45, hjust = 1)) "],["tidyr.html", "7 {tidyr} 7.1 pivot_longer() 7.2 unite()", " 7 {tidyr} Contiene funciones para re-estructurar dataframes. Similar al conocido “transponer” de excel. (fig/tidyr-pivot_wider_longer.gif) 7.1 pivot_longer() Por lo general en la etapa de toma de datos en el campo/lab (y su consiguiente pasaje a planilla electrónica, Excel) nos resulta más cómodo que las planillas de papel tengan un formato wide. En muchas ocasiones necesitamos (para graficar o modelar) que nuestros datos estén en formato long. La función pivot_longer apila las columnas que indiquemos, re-arregando los datos de un formato “wide” a “long”: Importemos soja soja &lt;- rio::import(&quot;data/datos_curso.xls&quot;, sheet =&quot;soja&quot;) soja En este caso necesitamos generar una columna bk y yield, o sea, tornar soja de “wide” a “long”: soja %&gt;% pivot_longer(cols=c(bk_1, bk_2, bk_3, bk_4), # contains(&quot;_&quot;) # bk_1:bk_4 names_to = &quot;bk&quot;, values_to = &quot;yield&quot;, names_prefix = &quot;bk_&quot;) -&gt; soja_long Tambien es comun para medidas repetidas en el tiempo canola &lt;- rio::import(&quot;data/datos_curso.xls&quot;, sheet =&quot;canola&quot;) canola canola %&gt;% pivot_longer( cols=contains(&quot;_&quot;), names_to = &quot;tt&quot;, values_to = &quot;inc&quot;, names_prefix = &quot;inc_&quot;)-&gt; can_long can_long str(can_long) can_long %&gt;% mutate_at(&quot;tt&quot;, as.numeric) %&gt;% ggplot()+ aes(x=tt, y=inc, group=1)+ geom_line() + facet_grid(bk ~ trt) 7.2 unite() can_long %&gt;% unite(col=&quot;par&quot;, bk, trt, sep = &quot;_&quot;, remove = FALSE) -&gt; can_long2 can_long2 %&gt;% mutate_at(&quot;tt&quot;, as.numeric) %&gt;% ggplot()+ aes(x=tt, y=inc, group=1)+ geom_line() + facet_wrap(&quot;par&quot;) bce_full %&gt;% select(date, tmean, rad, pp) %&gt;% pivot_longer(cols = -date, names_to = &quot;var&quot;, values_to = &quot;val&quot;) -&gt; bce_full_long bce_full_long # bce_full_long %&gt;% # mutate( # var= fct_recode(var, # &quot;Radiation (Mj/m2)&quot; =&quot;rad&quot;, # &quot;Mean Temperature (ºC)&quot;=&quot;tmean&quot;, # &quot;Precipitation (mm)&quot;=&quot;pp&quot;) # ) %&gt;% ggplot(bce_full_long) + aes(x = date, y = val) + geom_line(data = subset(bce_full_long, var!=&quot;pp&quot;)) + geom_col(data = subset(bce_full_long, var==&quot;pp&quot;)) + facet_grid(var~., scales = &quot;free&quot;) + scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;)+ theme_bw() + theme(axis.text.x = element_text(angle=45, hjust = 1)) + labs(x=&quot;&quot;, y=&quot;&quot;) "],["otras-importaciones.html", "8 Otras importaciones 8.1 Importación multiple con {rio} 8.2 Desde googlesheets 8.3 API de Nasapower 8.4 Exportar", " 8 Otras importaciones 8.1 Importación multiple con {rio} library(rio) bce_serie &lt;- bind_rows( import_list(file= &quot;data/eea_serie.xls&quot;), .id = &quot;year&quot;) bce_serie 8.2 Desde googlesheets Importemos “soja” url_soja &lt;- &quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1579441844&quot; browseURL(url_data) soja &lt;- rio::import(url_soja) %&gt;% clean_names() soja 8.3 API de Nasapower Meteo de Balcarce durante 2020 pacman::p_load(nasapower) bce_rad_2018 &lt;- get_power( community = &quot;AG&quot;, lonlat = c(-58.3, -37.75), pars = c(&quot;ALLSKY_SFC_SW_DWN&quot;), dates = c(&quot;2018-1-1&quot;, &quot;2018-12-30&quot;), temporal_api = &quot;daily&quot; ) bce_rad_2018 Clima de Balcarce bce_clima &lt;- get_power( community = &quot;ag&quot;, pars = c(&quot;RH2M&quot;, &quot;T2M&quot;, &quot;ALLSKY_SFC_SW_DWN&quot;), lonlat = c(-58.3, -37.75), temporal_api = &quot;climatology&quot; ) bce_clima Comparamos la estacion meteorologica de la EEA con los datos de nasapower bce_full %&gt;% left_join(bce_rad_2018, by = c(&quot;date&quot; = &quot;YYYYMMDD&quot;)) -&gt; bce_full_nasa bce_full_nasa %&gt;% ggplot() + aes(x=rad, y=ALLSKY_SFC_SW_DWN) + geom_point() + geom_smooth(method=&quot;lm&quot;) 8.4 Exportar export(bce_full_nasa, file=&quot;data/bce_wea_2018.xlsx&quot;) "],["correlacion.html", "9 Correlacion 9.1 Simple 9.2 Multi-level", " 9 Correlacion 9.1 Simple pacman::p_load(tidyverse, GGally, correlation, ggcorrplot, viridis) GGally iris %&gt;% ggpairs() correlation correlation (del ecosistema easystats) iris_corr &lt;- iris %&gt;% correlation(method = &quot;pearson&quot;) #spearman iris_corr iris_corr %&gt;% ggplot() + aes(x=Parameter1, Parameter2, fill= r)+ geom_tile() iris_corr %&gt;% ggplot(aes(x=fct_relevel(Parameter1, &quot;Sepal.Length&quot;, after = 2), y=fct_relevel(Parameter2, &quot;Petal.Width&quot;), fill= r)) + geom_tile() + scale_fill_viridis(discrete=FALSE, direction = -1) + labs(x=&quot;&quot;, y=&quot;&quot;) + geom_text(aes(label=r %&gt;% round(2)), col=&quot;white&quot;) + coord_flip()+ theme_minimal() ggcorrplot iris %&gt;% select_if(is.numeric) %&gt;% cor() %&gt;% round(2) %&gt;% ggcorrplot(hc.order = TRUE, type = &quot;lower&quot;, lab = TRUE) 9.2 Multi-level iris %&gt;% ggpairs(aes(color = Species)) iris_corr_sp &lt;- iris %&gt;% group_by(Species) %&gt;% correlation() # %&gt;% iris_corr_sp # %&gt;% knitr::kable() Es aqui donde pasa el investigador al frente del analista a interpretar los patrones Veamos un ejemplo clasico multi-level: Simpson’s paradox simpson &lt;- simulate_simpson(n = 100, groups = 10) simpson simpson %&gt;% ggplot()+ aes(x = V1, y = V2) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) correlation(simpson) simpson %&gt;% ggplot() + aes(x = V1, y = V2, col = Group) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(colour = &quot;black&quot;, method = &quot;lm&quot;, se = FALSE) Parece que, para cada sujeto, la relación es diferente. La tendencia negativa (global) parece ser un producto de las diferencias entre los grupos y podría ser espuria Las correlaciones multinivel (como en multigrupo) nos permiten dar cuenta de las diferencias entre grupos. Se basa en una parcialización del grupo, ingresada como efecto aleatorio en una regresión lineal mixta. Puede calcularlos con el paquete de correlaciones configurando el argumento multinivel en VERDADERO. simpson %&gt;% group_by(Group) %&gt;% correlation() simpson %&gt;% correlation(multilevel = TRUE) Ojo con las correlaciones! anscombe_long &lt;- rio::import(&#39;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1709959158&#39;) anscombe_long %&gt;% group_by(set) %&gt;% summarise(x_mean = mean(x), y_mean = mean(y), x_sd = sd(x), y_sd = sd(y)) anscombe_long %&gt;% group_by(set) %&gt;% correlation(method = &quot;pearson&quot;) anscombe_long %&gt;% ggplot() + aes(x, y) + geom_point() + geom_smooth(method=&quot;lm&quot;)+ facet_wrap(&quot;set&quot;) Conclusion: SIEMPRE plotear los datos crudos y los residuos Como pasar “anscombe” de wide a long data(anscombe) anscombe_long &lt;- anscombe %&gt;% pivot_longer( cols = everything(), # apilar solo el valor en la columna &quot;set&quot; names_to = c(&quot;.value&quot;, &quot;set&quot;), # indico que las columnas que estoy apilando tienen su primer digito con el nombre de una variable y el segundo digito con el nro de set names_pattern = &quot;(.)(.)&quot; ) %&gt;% arrange(set, x) "],["regresión-linear.html", "10 Regresión linear 10.1 Simple 10.2 Regresión polinomial 10.3 Regresion multiple", " 10 Regresión linear pacman::p_load(tidyverse, performance, ggeffects) performance ggeffects 10.1 Simple lm1 &lt;- lm(y~x, data=anscombe_long %&gt;% filter(set==1)) check_model(lm1) check_outliers(lm1) anova(lm1) summary(lm1) Agregar formula y R2 library(ggpmisc) formu &lt;- y ~ x anscombe_long %&gt;% filter(set==1) %&gt;% ggplot() + aes(x, y) + geom_point() + geom_smooth(method=&quot;lm&quot;)+ stat_poly_eq(formula = formu, aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), parse = TRUE) 10.2 Regresión polinomial Es un caso especial de la Regresión Lineal, enriquece el modelo lineal al aumentar predictores adicionales, obtenidos al elevar cada uno de los predictores originales a una potencia. La regresión ajustada parece correcta para el set 1, pero veamos para el set 2 lm2 &lt;- lm(y~x, data=anscombe_long %&gt;% filter(set==2)) check_model(lm2) check_outliers(lm2) lm2.sq &lt;- lm(y~x + I(x^2), data=anscombe_long %&gt;% filter(set==2)) compare_performance(lm2, lm2.sq) Regresiones lineales seriales library(broom) lm_ans_coef &lt;- anscombe_long %&gt;% group_by(set) %&gt;% do(tidy(lm(data = ., formula = y ~ x))) lm_ans_coef lm_ans_stats &lt;- anscombe_long %&gt;% group_by(set) %&gt;% do(glance( lm(data = ., formula = y ~ x)) ) lm_ans_stats Ahora veamos un caso del dataset cars cars %&gt;% ggplot()+ aes(speed, dist)+ geom_point() cars %&gt;% ggplot()+ aes(speed, dist)+ geom_point()+ # geom_smooth()+ geom_smooth(method = lm)+ # geom_smooth(method = lm, formula = y ~ poly(x, 1), ) + geom_smooth(method = lm, formula = y ~ poly(x, 2), col=&quot;red&quot;) Ajustamos las dos alternativas fit1 &lt;- lm(dist ~ speed, data = cars) check_model(fit1) fit2 &lt;- lm(dist ~ speed + I(speed^2), data = cars) compare_performance(fit1, fit2) summary(fit2) pred_fit2 &lt;- ggpredict(fit2, terms = c(&quot;speed&quot;)) pred_fit2 %&gt;% plot(add.data = TRUE, limit.range = TRUE) 10.3 Regresion multiple La regresión lineal múltiple permite generar un modelo lineal en el que el valor de la variable dependiente o respuesta (Y) se determina a partir de un conjunto de variables independientes llamadas predictores (X1, X2, X3…) Volvamos a iris para tratar de modelar Sepal.Width ~ Sepal.Length model1 &lt;- lm(Sepal.Width ~ Sepal.Length, data = iris) model2 &lt;- lm(Sepal.Width ~ Sepal.Length * Species, data = iris) # model2 &lt;- lm(Sepal.Width ~ Sepal.Length + Species + Sepal.Width:Species, data = iris) model3 &lt;- lm(Sepal.Width ~ Sepal.Length + Species, data = iris) model4 &lt;- lm(Sepal.Width ~ Sepal.Length:Species, data = iris) compare_performance(model1, model2, model3, model4) anova(model2) check_model(model2) pred_mod &lt;- ggpredict(model2, terms = c(&quot;Sepal.Length&quot;, &quot;Species&quot;)) pred_mod %&gt;% plot(add.data = TRUE, limit.range = TRUE) Como se corrije la Simspon`s paradox? Atribuyendo efecto aleatorio a los grupos, library(lme4) simpson_lm &lt;- lm(V2 ~ V1, data=simpson) simpson_mixed &lt;- lmer(V2 ~ V1 + (1|Group), data=simpson) ggpredict(simpson_lm) %&gt;% plot(add.data = TRUE) ggpredict(simpson_mixed) %&gt;% plot(add.data = TRUE) "],["anova.html", "11 Anova 11.1 Un solo factor 11.2 Dos factores", " 11 Anova # install.packages(&quot;multcompView&quot;) # solo una vez y no hace falta cargarlo pacman::p_load( tidyverse, skimr, # exploracion numerica de los datos performance, # evaluar performance de los modelos emmeans, # medias estimadas por el modelo multcomp # comparar las medias entre si - tukey ) 11.1 Un solo factor Experimento DCA: dataset PlantGrowth pg &lt;- PlantGrowth # simplificamos el nombre del dataset pg PlantGrowth {datasets} Results from an experiment to compare yields (as measured by dried weight of plants) obtained under a control and two different treatment conditions. 1- Exploración numérica str(pg) # tipo de variables pg %&gt;% group_by(group) %&gt;% skimr::skim() # exploración numérica pg %&gt;% group_by(group) %&gt;% summarise( n = sum(!is.na(weight)), mean = mean(weight), sd = sd(weight)) 2- Exploración visual pg %&gt;% ggplot()+ aes(x=group, y=weight) + geom_boxplot(width=0.2)+ geom_jitter(alpha=0.2, width=0.2) 3- Ajuste del modelo lineal mod1 &lt;- lm(weight ~ group, data = pg) \\[y_{ij} = \\mu + \\alpha_i + e_{ij}; \\:\\:i = 1,..., k; \\:j = 1,..., n\\] \\[N \\sim (\\sigma^2, 0)\\] 5- Diagnósticos ¿Las varianzas (entre niveles del factor) son homogéneas? check_heteroscedasticity(mod1) %&gt;% plot # plot(mod1, which = 1) # car::leveneTest(mod1) ¿Los residuos se distribuyen normales? check_normality(mod1) %&gt;% plot # plot(mod1, which = 2) # shapiro.test(rstandard(mod1)) 6- Estadisticas anova(mod1)# caso balanceado summary(mod1) # car::Anova(mod1)# caso desbalanceado 7- Comparaciones múltiples {-} Paquete emmeans Medias e intervalos de confianza estimadas por el modelo em &lt;- emmeans(mod1, ~ group, type=&quot;response&quot;) em # %&gt;% knitr::kable() class(em) Test de Tukey res &lt;- cld(em, Letters = letters, reverse = TRUE, alpha = .05) res ?pwpm pwpm(em, adjust = &quot;none&quot;) res &lt;- res %&gt;% mutate(letras = str_squish(.group), weight = emmean) 8- Grafico final res %&gt;% ggplot() + aes(x=group, y=weight)+ geom_pointrange(aes(ymin = lower.CL, ymax = upper.CL))+ labs(x = &quot;Tratamiento&quot;, y = &quot;Peso (g)&quot;)+ geom_text(aes(label = letras), angle=90, vjust=-1)+ geom_jitter(data = pg, width = .1, alpha=.5) + theme_bw() Comparación de medias de los trat vs testigo (Dunnet) contrast(em, &quot;trt.vs.ctrl1&quot;) Comparación de medias por LSD library(agricolae) res_lsd &lt;- LSD.test(y = mod1, trt = &quot;group&quot;, group = T, console = T) res_lsd bar.group(x = res_lsd$groups, ylim=c(0, 7), # main=&quot;Prueba de comparación de medias por medio del método LSD&quot;, # xlab=&quot;Tipo de Mezcla&quot;, # ylab=&quot;Rendimiento del proceso&quot;, col=&quot;steelblue&quot;) 11.2 Dos factores Datos festuca Las plantas tienen un pH del suelo óptimo para el crecimiento, y esto varía entre especies. En consecuencia, esperaríamos que si cultivamos dos plantas en competencia entre sí a diferentes valores de pH, el efecto de la competencia podría variar según el pH del suelo. En un estudio reciente se investigó el crecimiento de la gramínea Festuca ovina (Festuca de oveja) en competencia con el brezo Calluna vulgaris (Ling) en suelos con diferente pH. Calluna está bien adaptada para crecer en suelos muy ácidos, como en los pantanos de arena. Festuca crece en suelos con un rango mucho más amplio de pH. Podríamos suponer que Calluna será un mejor competidor de Festuca en suelos muy ácidos que en suelos moderadamente ácidos. Para probar esta hipótesis, se diseñó un experimento en el que se cultivaron plántulas de Festuca en macetas en todas las combinaciones de dos niveles de dos tipos diferentes de tratamiento festuca &lt;- structure(list(weight = c(2.76, 2.39, 2.54, 3.11, 2.49, 4.1, 2.72, 2.28, 3.43, 3.31, 3.21, 4.1, 3.04, 4.13, 5.21, 5.92, 7.31, 6.1, 5.25, 8.45), ph = c(&quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH3.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;, &quot;pH5.5&quot;), Calluna = c(&quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Present&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;, &quot;Absent&quot;)), row.names = c(NA, 20L), class = &quot;data.frame&quot;) # festuca &lt;- rio::import(&quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=477107180&quot;) festuca &lt;- rio::import(&quot;data/datos_curso.xls&quot;, sheet =&quot;festuca&quot;) Exploracion {-} festuca %&gt;% janitor::tabyl(ph, Calluna) festuca %&gt;% skim() festuca &lt;- festuca %&gt;% mutate_if(is.character, as.factor) festuca %&gt;% skim() dodge &lt;- position_dodge(width=0.5) festuca %&gt;% ggplot() + aes(x = ph, y = weight, fill = Calluna) + geom_boxplot(position = dodge, alpha=.5) + geom_point(position = dodge) # geom_line(aes(group=supp), stat = &quot;summary&quot;, fun=mean) Ajuste {-} fest_fit &lt;- lm(weight ~ ph * Calluna, data = festuca) fest_fit_log Diagnósticos {-} ¿Las varianzas (entre niveles del factor) son homogéneas? check_heteroscedasticity(fest_fit) # %&gt;% plot ¿Los residuos se distribuyen normales? check_normality(fest_fit) # %&gt;% plot Transformación {-} Transformación potencia óptima de boxcox Esta transformación sólo tiene un parámetro: lambda, graficado en el eje x. Si el valor de lambda es igual a cero, se lleva a cabo la transformación con el logaritmo natural, y si dicho valor es distinto a cero la transformación es potencial. Si el parámetro lambda es igual a uno, no hace falta transformar la variable respuesta. Si el intervalo (líneas punteadas verticales) no contiene a 0 ni a 1, hay que transformar la variable elevando a la potencia del valor de lamba incluido en el intervalo. La utilización de la transformación Box-Cox requiere que todos los valores de la serie de entrada sean positivos y distintos a cero. Por ello es adicionada una constante a la variable original (0.5, por ej.). En el caso que la transformacion optima sea lambda = 0.2, el modelo resultaría: lm((y+0.5)^0.2 ~ trt ...) boxcox(fest_fit) Se sugiere transformacion log ya que el lambda optimo contiene al 0 Reajuste de modelo {-} …con variable respuesta transformada fest_fit_log &lt;- lm(log(weight) ~ Calluna * ph, data = festuca) Nuevamente se diagnostica la estabilizacion de la varianza check_heteroscedasticity(fest_fit_log) %&gt;% plot Estadisticas del modelo {-} anova(fest_fit_log) Medias estimadas por el modelo {-} … y su dispersion fest_em &lt;- emmeans(fest_fit_log, ~ Calluna | ph, type = &quot;response&quot;) fest_em Comparaciones multiples {-} res_festuca &lt;- cld(fest_em, alpha=.05, Letters=letters) res_festuca Grafico final {-} res_festuca &lt;- res_festuca %&gt;% mutate(letras=str_squish(.group), weight=response) res_festuca %&gt;% ggplot() + aes(x=ph, y=weight, col=Calluna)+ geom_pointrange(aes(ymin = lower.CL, ymax = upper.CL), position = dodge)+ labs(x = &quot;&quot;, y = &quot;Weight (g)&quot;)+ geom_text(vjust=-1, angle=90, aes(label = letras), position = dodge)+ # geom_jitter(data = festuca, alpha=0.2, position = position_dodge(width=0.5)) + theme_bw() Lexturas recomendadas Analysis and Interpretation of Interactions in Agricultural Research Analysis of Combined Experiments Revisited Model Syntax in R ANOVA: A Short Intro Using R glmmFAQ A brief introduction to mixed effects modelling and multi-model inference in ecology Data Analysis Examples Data Analysis and Visualization in R for Ecologists RNAseq analysis with R ::: "],["mapas.html", "12 Mapas 12.1 Paquete sf 12.2 Choropleth maps 12.3 Mapa de clima 12.4 Mapa de Muestreos", " 12 Mapas Son muchos los paquetes relacionados a GIS en R con multiplicidad de funciones https://rspatialdata.github.io/ library(tidyverse) library(viridis) Obtención de datos georeferenciaodos remotes::install_gitlab(&quot;dickoa/rgeoboundaries&quot;) library(rgeoboundaries) library(raster) library(rnaturalearth) # install.packages(&quot;rnaturalearthdata&quot;) Generacion de mapas con sintaxis acoplable a ggplot library(sf) library(leaflet) library(htmltools) library(ggspatial) Hay otros muy interesantes como tmap, mapview que pueden encontrar mucha informacion en internet 12.1 Paquete sf Obtenemos limites politicos de Africa africa &lt;- ne_countries(continent = &quot;Africa&quot;, returnclass = &quot;sf&quot;, scale = &quot;medium&quot;) africa Primer grafico africa %&gt;% ggplot()+ geom_sf() https://docs.qgis.org/2.8/es/docs/gentle_gis_introduction/coordinate_reference_systems.html africa %&gt;% ggplot()+ geom_sf() + coord_sf(crs = st_crs(&quot;ESRI:54030&quot;)) # Robinson africa %&gt;% ggplot()+ geom_sf() + coord_sf(crs = st_crs(&quot;EPSG:3395&quot;)) # Mercator Manipualacion con dplyr head(africa) zambia &lt;- africa %&gt;% filter(sovereignt==&quot;Zambia&quot;) zambia %&gt;% ggplot()+ geom_sf() Una capa por dataframe africa %&gt;% ggplot()+ geom_sf() + geom_sf(data=zambia, fill=&quot;gray50&quot;) Obtenemos limites provinciales con rgeoboundaries zambia_adm1 &lt;- geoboundaries(c(&quot;Zambia&quot;), &quot;adm1&quot;) zambia_adm1 %&gt;% ggplot() + geom_sf() zambia_adm2 &lt;- geoboundaries(c(&quot;Zambia&quot;), &quot;adm2&quot;) zambia_adm2 zambia_adm2 %&gt;% ggplot() + geom_sf() #+ # geom_sf_text(aes(label = shapeName), size=2) # coord_sf(xlim = c(22, 30), ylim = c(-10, -16)) Hasta ahora veniamos con graficos estáticos Veamos uno dinámico con leaflet library(htmltools) zambia_adm2 %&gt;% leaflet() %&gt;% addTiles() %&gt;% addPolygons(label = zambia_adm1$shapeName, weight=1, popup = ~htmlEscape(shapeID)) 12.2 Choropleth maps Agreguemos una variable ficticia zambia_adm1 &lt;- zambia_adm1 %&gt;% mutate(y=rnorm(10, 1000, 200)) zambia_adm1 %&gt;% ggplot() + geom_sf(aes(fill=y)) + scale_fill_viridis(direction=-1) # scale_fill_viridis(option = &quot;plasma&quot;) Por ejemplo, podemos practicar esto mismo con datos reales poblacionales con el paquete wopr https://rspatialdata.github.io/population.html 12.3 Mapa de clima https://rspatialdata.github.io/temperature.html Descarguemos temperatura maxima mensual con raster tmax_data &lt;- getData(name = &quot;worldclim&quot;, var = &quot;tmax&quot;, res = 10) # Converting temperature values to Celcius gain(tmax_data) &lt;- 0.1 # Calculating mean of the monthly maximum temperatures tmax_mean &lt;- mean(tmax_data) Extraemos los datos de zambia tmax_mean_zam &lt;- raster::mask(tmax_mean, as_Spatial(zambia_adm1)) Converting the raster object into a dataframe tmax_mean_zambia_df &lt;- as.data.frame(tmax_mean_zam, xy = TRUE, na.rm = TRUE) tmax_mean_zambia_df %&gt;% ggplot(aes(x = x, y = y)) + geom_raster(aes(fill = layer)) + geom_sf(data = zambia_adm1, inherit.aes = FALSE, fill = NA) + labs( title = &quot;Mean monthly maximum temperatures in zambia&quot;, subtitle = &quot;For the years 1970-2000&quot; ) + xlab(&quot;Longitude&quot;) + ylab(&quot;Latitude&quot;) + scale_fill_gradient( name = &quot;Temperature (°C)&quot;, low = &quot;#FEED99&quot;, high = &quot;#AF3301&quot; ) 12.4 Mapa de Muestreos Supongamos que queremos plotear muestreos de especies realizados entre 2020 y 2021 en las provincias de Misiones y Corrientes Descargamos limites politicos a nivel de municipiocon raster # arg_adm2 &lt;- geoboundaries(c(&quot;Argentina&quot;), &quot;adm2&quot;) # arg_adm2 mis_corr &lt;- getData(country = &quot;ARG&quot;, level = 2) %&gt;% st_as_sf() %&gt;% filter(NAME_1 %in% c(&quot;Misiones&quot;, &quot;Corrientes&quot;)) %&gt;% st_transform(crs = 4326) mis_corr mis_corr %&gt;% ggplot() + geom_sf() + theme_minimal() Generamos 120 puntos de muestreo aleatorios, donde solo registramos su especie (A o B), las coordenadas y el tamaño del especimen (media=10, sd=2) sampling_points &lt;- expand_grid(year=as.integer(2020:2021), sp=LETTERS[1:2], rep=1:30) sampling_points sampling_points &lt;- sampling_points %&gt;% mutate(coord=st_sample(mis_corr, 120), size = rnorm(120, 10, 2)) %&gt;% st_sf() sampling_points Ahora queremos fusionar con el dataset con los municipios donde cayeron los puntos de muestreo sampling_points_muni &lt;- st_join(sampling_points, mis_corr) sampling_points_muni Veamos que tal cayeron los puntos ggplot()+ geom_sf(data=mis_corr)+ geom_sf(data=sampling_points, aes(col=sp))+ facet_wrap(&quot;year&quot;) + theme_void() # theme_map() Y si hubo algun patron en el tamaño de los especimenes registrados ggplot()+ geom_sf(data=mis_corr, col=&quot;gray70&quot;)+ geom_sf(data=sampling_points, aes(color=size))+ facet_grid(sp~year) + scale_color_viridis_c() + theme_minimal() Y algunos graficos con medidas aritmeticas sampling_points_muni %&gt;% count(year, NAME_1, sp) %&gt;% ggplot() + aes(x=year, y=n, col=sp) + geom_line() + facet_wrap(&quot;NAME_1&quot;) sampling_points_muni %&gt;% count(NAME_1, NAME_2, sp) %&gt;% ggplot() + aes(x=NAME_2, y=n, fill=sp) + geom_bar(position=&quot;stack&quot;, stat=&quot;identity&quot;) + facet_wrap(&quot;NAME_1&quot;, scales = &quot;free&quot;)+ coord_flip() Y si no nos interesa los municipios y tenemos los datos exprtados de una planilla de excel… El paquete ggspatial nos provee un mapa base samp_xls &lt;- sampling_points %&gt;% mutate(lon = sf::st_coordinates(.)[,1], lat = sf::st_coordinates(.)[,2]) %&gt;% as_tibble() %&gt;% dplyr::select(-coord) samp_xls samp_xls %&gt;% ggplot(aes(x = lon, y = lat, col=sp)) + annotation_map_tile(type = &quot;cartolight&quot;, zoomin = 0) + geom_spatial_point() + # ylim(c(-52, 40)) + # xlim(c(-115, -40)) + facet_wrap(&quot;year&quot;) + guides(size=&quot;none&quot;) + coord_sf(crs = 4326) library(sf) cities &lt;- data.frame( longitude = c(-58.3612, -58.3173, -58.2940, -58.7228, -57.9556, -58.2395), latitude = c(-38.0165, -37.9428, -37.5447, -37.6301, -37.8666, -37.6467), city = c(&quot;San Agustin&quot;, &quot;Los Pinos&quot;, &quot;Ramos Otero&quot;, &quot;Napaleofu&quot;, &quot;La Brava&quot;, &quot;Bosch&quot;) ) cities %&gt;% ggplot( aes(longitude, latitude)) + annotation_map_tile(zoom = 10) + geom_spatial_point() + geom_spatial_label_repel(aes(label = city))+ fixed_plot_aspect() # coord_sf(crs = 3995) Referencias https://afrimapr.github.io/afrimapr.website/ https://afrimapr.github.io/afrilearnr/ https://mgimond.github.io/Spatial/index.html https://paleolimbot.github.io/ggspatial/articles/ggspatial.html#sample-data-1 https://docs.ropensci.org/rnaturalearth/ https://datavizs21.classes.andrewheiss.com/example/12-example/ https://luisdva.github.io/rstats/mapassf/ https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html library(rgeoboundaries) # https://rspatialdata.github.io/admin_boundaries.html library(rnaturalearth) # https://docs.ropensci.org/rnaturalearth/articles/rnaturalearth.html library(sf) # https://keen-swartz-3146c4.netlify.app/ library(ggspatial) # https://paleolimbot.github.io/ggspatial/ library(rworldmap) # https://bookdown.org/angelborrego/ciencia_datos/mapas.html#mapas-con-rworldmap library(pointdensityP) # https://mgimond.github.io/Spatial/chp11_0.html "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
