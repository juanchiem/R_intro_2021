[["index.html", "Exploración, manipulación y visualización de datos con R Motivación", " Exploración, manipulación y visualización de datos con R Motivación “Una de las cosas más importantes que puedes hacer es dedicar un tiempo para aprender un lenguaje de programación. Aprender a programar es como aprender otro idioma: requiere tiempo y entrenamiento, y no hay resultados prácticos inmediatos. Pero si superas esa primera subida empinada de la curva de aprendizaje, las ganancias como científico son enormes. Programar no sólo te liberará de la camisa de fuerza de los softwares estadísticos cerrados, sino que también agudizará tus habilidades analíticas y ampliará los horizontes de modelado ecológico y estadístico.” ~ Adaptación de (Ellison and Gotelli 2004) ~ Podríamos resumir nuestro trabajo como científicos, desde la recolección de datos en el campo, hasta su divulgación a través del siguiente esquema: ~ Adaptación de “R for Data Science” (Wickham and Grolemund 2016) ~ Objetivos El curso pretende proveer herramientas de programación básicas para llevar adelante el proceso de investigación tomando como base el esquema de trabajo anterior. Para ello, usaremos datos (reales o simulados) típicos del área de Ciencias Agrarias. Importante: i) no es un curso de estadística; ii) entendemos la programación como un simple medio para optimizar nuestra labor cotidiana (no como un fin mismo), al final del día seguiremos siendo fitopatólogos, fisiólogos, bioquímicos, etc.; iii) maximizaremos la adopción de la filosofía tidyverse; y iv) obtendrán mayor provecho aquellas personas que se inician en R, ya que los contenidos pretenden ser de baja complejidad, posibilitando profundizar el conocimiento por los propios medios del alumno. ¿Por qué R? (R Core Team 2017) 1 Software libre - multiplataforma 2 Aprender un lenguaje de programación: ejercicio mental/lógica (Aprender estadística resulta mucho mas ameno) 3 Software actualizado y con una amplia gama de paquetes específicos (drc, agricolae, epiphy…) 4 Gran flexibilidad y elegancia de los gráficos 5 Popularidad - Comunidad activa y creciente dispuesta a ayudar (aprendemos a usar terminos técnicos de ciencia de datos en inglés) 6 Programar ya no es sólo computación (CV/relevant skills) Autor Juan Pablo Edwards Molina: Investigador :: Fitopatología (INTA Balcarce). Email: edwardsmolina@gmail.com Google scholar Twitter: juanchiem GitHub: https://github.com/juanchiem References "],["config.html", "1 Configuraciones básicas Paquetes de R Workflow componentes", " 1 Configuraciones básicas Instalación de programas 1° R 2° R Studio (bajar la versión Free) RStudio es un entorno de desarrollo integrado (IDE) para el lenguaje de programación R, o sea es la interface por medio de la cual se ejecutan acciones en R. Configuraciones iniciales (sugeridas). Dirigirse a la sección “Tools/Global options” Paquetes de R Un paquete es una colección de funciones, datos y código R que se almacenan en una carpeta conforme a una estructura bien definida, fácilmente accesible para R. Un repositorio es un lugar donde se alojan los paquetes para que pueda instalarlos desde él. Los repositorios mas populares son: CRAN: repositorio oficial. Es una red de servidores web mantenida por la comunidad R en todo el mundo. El Core Team de R lo coordina, y para que un paquete se publique aquí, debe pasar varias pruebas que aseguren el cumplimiento de las políticas de CRAN. GITHUB: probablemente el repositorio más popular para proyectos particulares de código abierto. No es específico de R (sin proceso de revisión asociado). Bioconductor: repositorio destinado a software de código abierto para bioinformática. Como CRAN, tiene sus propios procesos de presentación y revisión, y su comunidad es muy activa y tiene varias conferencias y reuniones al año. La simple instalación de R trae consigo múltiples paquetes que permiten un funcionamiento básico de importación de datos, ajuste y evaluación de modelos estadísticos y representaciones gráficas. Sin embargo, la enorme potencia de R deriva de su capacidad de incorporar nuevas funciones generadas por su gran comunidad de usuarios En la web de R se puede consultar la lista de paquetes disponibles, y en la sección Task Views se puede consultar los mismos ordenados por áreas de aplicación. Links para exploración o chequeo de novedades de paquetes: Rdocumentation METACRAN r weekly r-bloggers revolution analytics RStudio blog Existen varias vias de instalación de paquetes: Via consola: install.packages(\"nombre_del_paquete\") O simplemente en el panel de paquetes. Una vez instalado, hay que cargar los paquetes que contienen las funciones que vayamos a usar en cada sesión library(nombre-del-paquete) instale el paquete pacman y activelo Workflow componentes Varios tipos de archivos serán creados y usados durante una sesión de R: datos crudos (hojas de cálculo) - datos manipulados scripts gráficos reportes de resultados Una análisis debe poder ser retomado en cualquier momento pudiendo darse por concluída cuando el trabajo es publicado. Hasta entonces debemos tener rápido acceso a todos los objetos creados en sesiones anteriores. Para ello debemos manejarnos siempre bajo buenas prácticas de trabajo. Esto nos permitirá entender qué quisimos hacer tiempo atrás, seremos intuitivos para encontrar archivos/objetos, y finalmente crearemos trabajos reproducibles… Una forma práctica de administrar todos los objetos de una sesión es por medio del uso de “proyectos” de R Studio. Una sugerencia es generar subcarpetas en nuestras máquinas, en preferencia dentro de dropbox / google drive. Esto no sólo mantendrá nuestro trabajo resguardado de posibles pérdidas (backup), retomarlo desde diferentes máquinas (trabajo/casa), sino que también le permitirá compartir en tiempo real sus avances con los colaboradores de su trabajo. Crear una nuevo proyecto llamado “R_intro” Crear un script “dia_1” ¿Dónde se guardaría el siguiente gráfico? En este ejemplo, usaremos una función “plot()” y un dataset “pressure” prediseñados en paquetes de carga automática al iniciar R. plot(pressure) "],["sintaxis.html", "2 Sintaxis R Calculadora Comparaciones lógicas Variables y asignaciones Funciones Tips S.O.S. Tablas resumen", " 2 Sintaxis R Calculadora 4 + 9 4 - 3 * 1 #4%1 (4 + 5 ) * 7 - (36/18)^3 Ver tablas resumen de operadores aritméticos y lógicos (al final del capítulo) Reto matemático que se volvió viral en las redes sociales* Existen dos soluciones, según método que se aplique: el PEMDAS = 1 (parenthesis &lt; exponents &lt; multiplicación &lt; division &lt; addition &lt; subtraction) y el BODMAS = 16 (Brackets &lt; Orders (Powers and Square Roots) &lt; Division &lt; Multiplication &lt; Addition &lt; Subtraction). Cómo opera R? Se puede decir que hay diferencia de estilos al programar. Se deberia tener presente que otros pueden leer tu código (optar por buenas prácticas) (3+(5*(2^2))) # difícil de leer 3 + 5 * 2 ^ 2 # si se recuerdan las reglas, todo bien 3 + 5 * (2 ^ 2) # si se olvidan algunas reglas, esto podría ayudar Comparaciones lógicas 4&gt;3 4 == 4 4 == 4 4 != 3 1 &gt;= -9 Variables y asignaciones Podemos almacenar valores en variables usando el operador de asignación &lt;-, veamos un ejemplo: x &lt;- 1/40 Esta asignación no muestra el valor, sino que lo almacena para más adelante en algo llamado “variable.” Que contiene x? x shortcut de “&lt;-” : Alt - Chequear la pestaña Environment en uno de los paneles de RStudio. Nuestra variable x se puede usar en lugar de un número en cualquier cálculo que espere un número: x &lt;- x + 1 # observen cómo RStudio actualiza/sobrescribe x en la pestaña superior derecha y &lt;- x * 2 El lado derecho de la asignación puede ser cualquier expresión de R válida. La expresión del lado derecho se evalúa por completo antes de que se realice la asignación. También es posible utilizar el operador = para la asignación x = 1/40 Esta forma es menos común entre los usuarios R (se recomienda usar &lt;-). Funciones Como dijimos, los paquetes son básicamente un conjunto de funciones generadas por los autores de los mismos pero el usuario puede crear sus propias funciones. Componentes de las funciones: nombre_funcion(argumentos) Nombre: Generalmente, el nombre es intuitivo, por ejemplo, mean es la función que calcula la media, round es la funión que redondea un número.(Como habrán notado R está en inglés) Argumentos: Un argumento es un marcador de posición. Cuando se invoca una función, se debe indicar valores a los argumentos. Los argumentos son opcionales; es decir, una función puede no contener argumentos. También los argumentos pueden tener valores por defecto. Algunos cálculos basados en funciones matemáticas. Son las mas simples, y no esta funcion no contienen argumentos. [para chequear la info de la función, solo basta con seleccionar todos sus caracteres + F1] sqrt(3) # 3^0.5 # 3^(1/2) log(10) # logaritmo natural exp(2.302585) # log(10, base=10) Funciones básicas pero con argumentos Redondeo round(4.3478) round(4.3478, digits=3) Tips 1 - No se tienen en cuenta los espacios en blanco entre palabras: podemos o no dejar espacios para que el código se pueda ordenar de forma adecuada y poder entenderse. plot( pressure ) plot(pressur e) 2 - Se distinguen las mayúsculas y minúsculas (“case sensitive”): para variables en el código, podemos crear diferentes variables con nombres iguales pero alternando mayúsculas y minúsculas. Plot(pressure) 3 - Se pueden incluir comentarios: como vimos anteriormente los comentarios se utilizan para añadir información en el código. De paso observamos que plot(pressur e) # da error # grafico press vs temp plot(pressure) Aprovechemos a ir describiendo los “argumentos” de las “funciones”: plot(pressure, # grafico press vs temp pch = 19, # cambio el tipo de puntos vacios a puntos llenos col= &quot;blue&quot; # uso color azul para rellenarlos ) 4 - El punto y coma (;) actúa como separador de comandos aún en la misma línea del script! pressure; plot(pressure) 5 - Los nombres de las variables pueden contener letras, números, guiones bajos y puntos, pero NO PUEDEN: comenzar con un número contener espacios en absoluto Cada uno adopta su propia forma para nombres largos de variables, por ej: puntos.entre.palabras guiones_bajos_entre_palabras MayúsculasMinúsculasParaSepararPalabras No importa como lo adopten, pero es aconsejable ser consistente. S.O.S. En el mismo R: ?sd; ??sd; F1 sobre la función Googlear: r generate a sequence of uppercase letters Stack Overflow en inglés / Stack Overflow en español / RStudio: comunidades altamente activas por los usuarios de R y otros lenguajes de programación. R Mailing Lists: especificas de cada área de la ciencia. ¿Cómo hacer una buena pregunta en las comunidades? Ser conciso pero gentil… Ser reproducible: su código debe correr en cualquier máquina. La comunidad no irá a ayudarle si no pueden reproducir su error (detallar paquetes y versión de R en caso necesario) Tablas resumen Table 2.1: Operadores aritméticos Operador Detalle x + y Suma de x e y x - y Resta de x menos y x * y Multiplicación x / y División de x por y x %/% y Parte entera de la división de x por y x %% y Resto de la división de x por y x ^ y x elevado a y-ésima potencia (equivalente a **) Table 2.2: Operadores lógicos Operador Prueba.lógica x &lt; y x menor que y? x &lt;= y x menor o igual que y? x &gt; y x mayor que y? x &gt;= y x mayor o igual que y? x == y x igual que y? x != y x diferente que y? Table 2.3: Funciones matemáticas Operador Detalle sqrt(x) raiz de x exp(y) exponencial de y log(x) logaritmo natural de x = ln log10(x) logaritmo base 10 de x sum(x) suma todos los elementos de x prod(x) producto de todos los elementos de x round(x, n) redondea x a n-digitos Table 2.4: Algunos atajos comúnmente usados Teclas Detalle Alt+Shift+K panel de todos los atajos Ctrl+Z / Ctrl+Shift+Z undo/redo Alt+ - &lt;- Ctrl+r corre la línea/bloque completa de código Ctrl+l limpia la consola Ctrl+Shift+c silencia la línea de código Ctrl+Shift+d duplica la línea de código Ctrl+i indexa el bloque de código Ver todos los atajos en R Studio Ctrl | Shift | k "],["tipos-de-datos.html", "3 Tipos de datos 3.1 Vectores Numéricos Lógicos Caracter Fechas 3.2 Secuencias 3.3 Números aleatorios 3.4 Valores especiales 3.5 Factores", " 3 Tipos de datos Para realizar un uso eficiente de R es preciso entender y aprender a manipular bien las distintas clases de objetos que maneja el programa. En esta sección nos vamos a ocupar particulamente de aquellos objetos que R utiliza para representar datos: valores, vectores y dataframes (hay más), y su naturaleza. Para un procesamiento correcto, un lenguaje de programación debe saber qué se puede y qué no se puede hacer con un valor en particular. Por ejemplo, no se puede sumar palabras “hola” y “mundo.” Del mismo modo, no puede cambiar los números 1 y -34.5 de minúsculas a mayúsculas. Debido a esto, R tiene una característica llamada tipos de datos. R proporciona las funciones class () y typeof () para averiguar cuál es la clase y el tipo de cualquier variable. R tiene cinco tipos de datos que son: Clase Ejemplo numérica 12.3, 5, 999, … lógica TRUE, FALSE caracter hola, JUAN… fecha 2021-05-06, 31/01/1965 3.1 Vectores En términos genéricos, todos los elementos que maneja R se consideran objetos: un valor numérico es un objeto, un vector es un objeto, una función es un objeto, una base de datos es un objeto, un gráfico es un objeto… La unidad básica de datos en R es un vector, los cuales pueden ser de diferentes clases. Los que más usaremos son las siguientes clases. vector &lt;- c(Concatenación, de, elementos, atómicos) # v0 &lt;- 8,9,11 v0 &lt;- c(8,9,11) # v00 &lt;- c(8) str(v0) v01 &lt;- c(8,9,11) typeof(v01) v0+v01 v1 &lt;- c(8, 7, 9, 10, 10, 111) v1 typeof(v1) str(v1) summary(v1) Supongamos que v1 es una muestra de la variable largo de raiz de trigo en cm plot(v1) edit(v1) v1 v1 &lt;- edit(v1) v1 # Medidas de posición mean(v1) median(v1) quantile(v1, 0.25) # Medidas de dispersión min(v1) max(v1) range(v1) var(v1) sd(v1) sqrt(var(v1)) Operaciones con vectores numéricos v1 - 1 sum(v1) cumsum(v1) Numéricos Tipos: integer vs double num &lt;- 8 class(num) typeof(num) inte &lt;- as.integer(num) class(inte) typeof(inte) num + inte # inte2 &lt;- 8L Lógicos El tipo de dato lógico o booleano es en computación aquel que puede representar valores de lógica binaria, esto es 2 valores: falso o verdadero logi &lt;- FALSE # logi &lt;- false class(logi) typeof(logi) as.logical(0) as.logical(1) Caracter Almacena valores de “caracteres” o “cadenas” (en inglés “string”): pueden contener letras, números y símbolos. La forma más sencilla de indicar que un valor es de tipo carácter es colocar el valor entre comillas simples o dobles. car &lt;- &quot;Hola mundo&quot; # carac &lt;- &#39;hola mundo&#39; class(car) typeof(car) car2 &lt;- as.character(&quot;Hola mundo&quot;) car3 &lt;- as.character(num) typeof(car3) Fechas Almacena valores de “caracteres” o “cadenas” (en inglés “string”): pueden contener letras, números y símbolos. La forma más sencilla de indicar que un valor es de tipo carácter es colocar el valor entre comillas simples o dobles. El formato default es yyyy-mm-dd fechas_vector &lt;- as.Date(c(&quot;2007-06-22&quot;, &quot;2004-02-13&quot;)) str(fechas_vector) Pero nosostros comunmente usamos ‘dd/mm/yyyy,’ así que debemos convertir fechas &lt;- c(&quot;01/06/2020&quot;, &quot;31/12/2020&quot;) str(fechas) fechas_date &lt;- as.Date(fechas, &quot;%d/%m/%Y&quot;) # con paquete base fechas_date &lt;- lubridate::dmy(fechas) # con lubridate! str(fechas_date) diff(fechas_date) Forzando las clases explícitamente as.character(), as.numeric(), as.integer() y as.logical() Si colocáramos dos o más clases diferentes dentro de un mismo vector, R va forzar a que todos los elementos pasen a pertenecer a una misma clase. El número 1.7 cambiaría a “1.7” si fuera creado junto con “a.” y1 &lt;- c(1.7, &quot;a&quot;) ## character class(y1) y2 &lt;- c(TRUE, 0, 10) ## numeric class(y2) y3 &lt;- c(TRUE, &quot;a&quot;) ## character class(y3) y4 &lt;- c(T, F) class(y4) as.numeric(y1) as.numeric(y3) as.numeric(y4) as.logical(y2) 3.2 Secuencias Numéricas 1:7 seq(from = 0, to = 20, #by=2) # length=4) rep(1:3, times=3) # , each=3 Letras LETTERS rep(c(&quot;a&quot;,&quot;b&quot;, &quot;c&quot;), times=3) # , each=3 Fechas seq(as.Date(&quot;2015-01-15&quot;), as.Date(&quot;2015-12-15&quot;), &quot;1 month&quot;) 3.3 Números aleatorios La generación de números aleatorios es en muchas ocasiones un requerimiento esencial en investigación científica. Proceder de este modo puede reducir cualquier sesgo generado por nuestra persona a la hora de seleccionar una muestra, o aplicar un tratamiento a una unidad experimental. Generar números enteros de modo aleatorio de una muestra determinada sample() set.seed(123) sample(1:30, size=10, replace=F) #sin reposición Generar números aleatorios de una distribución específica de parámetros conocidos: runif() - números racionales aleatoriamente, uniformemente distribuidos en un intervalo num_unif &lt;- runif(100, min=3, max=4) hist(num_unif) rnorm() - números aleatorios, pertenecientes a una población con distribución normal, con parámetros μ y σ. num_norm &lt;- rnorm(100, mean=70, sd=5) hist(num_norm) 3.4 Valores especiales Existen valores reservados para representar datos faltantes, infinitos, e indefiniciones matemáticas. NA (Not Available) significa dato faltante/indisponible. El NA tiene una clase, o sea, pueden ser NA numeric, NA character, etc. y &lt;- c(2, 4, NA, 6) is.na(y) Calcule el promedio de y (use la ayuda de R en caso necesario)mean(y) NaN (Not a Number) es el resultado de una operación matemática inválida, ej: 0/0 y log(-1). Un NaN es un NA, pero no recíprocamente. 0/0 is.nan(0/0) is.na(0/0) NULL es el vacío de R. Es como si el objeto no existiese a = NULL a Inf (infinito). Es el resultado de operaciones matemáticas cuyo límite es infinito, es decir, es un número muy grande, por ejemplo, 1/0 o 10^310. Acepta signo negativo -Inf. 1/0 1/Inf 3.5 Factores En R las variables categóricas se almacenan como factores tanto sea para vectores que contienen caracteres o enteros. Uno de los usos más importantes de los factores es en el modelado estadístico, dado que éstos tendran un efecto diferente a las variables contínuas. Claro ejemplo de factores son los tratamientos, por ej: fungicidas, genotipos, bloques, etc. Todo factor tiene sus atributos: x: el vector input (de tipo numérico o caracter) que será transformado a factor. Niveles (levels): es un set de valores únicos ordenados que aparecen en x. Podemos comprobar que la ordenación de los niveles es simplemente alfabética. geno &lt;- c(&quot;control&quot;, &quot;B35&quot;, &quot;A12&quot;, &quot;T99&quot;, &quot;control&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;T99&quot;, &quot;control&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;T99&quot;, &quot;control&quot;) class(geno) levels(geno) geno_f &lt;- factor(geno) levels(geno_f) table(geno_f) geno_f1 &lt;- factor(geno, levels=c(&quot;control&quot;, &quot;A12&quot;, &quot;B35&quot;, &quot;T99&quot;)) levels(geno_f1) trat &lt;- c(3, 5, 7, 1, 1, 5, 5, 7,5) trat_f &lt;- factor(trat) trat_f levels(trat_f) table(trat_f) Las variables numéricas y de caracteres se pueden convertir en factores (factorizar), pero los niveles de un factor siempre serán valores de caracteres. Podremos verlo en el siguiente ejemplo: vec_n &lt;- c(3, 7, 2) sum(vec_n) vec_f &lt;- factor(vec_n) vec_f levels(vec_f) labels(vec_f) vec_fn &lt;- as.numeric(vec_f) vec_fn; vec_n identical(vec_fn, vec_n) sum(vec_n) # ¿Cómo hizo la transformación R? Hemos recuperado los valores numéricos # originales (`vec`)? que representan los números codificados por R # en `vec_f`? vec_fcn &lt;- as.numeric(as.character(vec_f)) sum(vec_fcn) identical(vec_n, vec_fcn) "],["estructura-de-datos.html", "4 Estructura de datos Data frames", " 4 Estructura de datos Data frames Conjunto de variables (columnas), de cualquier tipo de datos (categóricas, lógicas, fechas. Un dataframe es completo con dimensiones n_fila x p_columna, donde: 1- Cada fila debe contener toda la info de la unidad experimental que se está evaluando 2- Cada columna representa una variable (descriptiva o respuesta) 3- Cada celda debe tener su observación (en caso de faltar el dato será un NA) x &lt;- c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;) y &lt;- c(1,3,5) dat &lt;- data.frame(x,y) dat str(dat) dat$ library(tibble) dat &lt;- tribble( ~x, ~y, &quot;A&quot;, 1, &quot;B&quot;, 3, &quot;C&quot;, 5 ) Como hemos visto, hay data frames contenidos en paquetes de inico automático. Un ejemplo muy usado, que está en el paquete base es el dataset “iris.” iris # ya activo desde inicio de sesión por default ?iris # F1 View(iris) # F2 str(iris) Explore el dataset iris con las siguientes funciones y anote sus resultados: dim(); head(); tail(); names(); str(); summary() Otras estructuras de datos Listas Objetos que aceptan elementos de clases diferentes. x &lt;- list(a = 1:5, b = c(&quot;a&quot;, &quot;b&quot;), c = TRUE) x (Más info de subsetting elementos de una lista aquí) x$a # x[1] # #sum(x[1]) x[[1]] # sum(x[[1]]) x[&quot;c&quot;] # Matrices Indicamos el número de filas con el argumento nrow y con ncol el número de columnas; luego indicamos qué valores forman la matriz (del 1 al 9), y le hemos pedido a R que use esos valores para rellenar la matriz A por filas con byrow=TRUE. La matriz A así construida es: A &lt;- matrix(nrow=3, ncol=3, c(1,2,3,4,5,6,7,8,9), byrow=TRUE) "],["visualización.html", "5 Visualización ggplot 5.1 Ambas variables contínuas 5.2 Comparación de niveles de factores", " 5 Visualización ggplot El paquete ggplot2 tiene una flexibilidad tal que permite generar rápidamente gráficos exploratorios así como crear figuras complejas, detalladas, de alta calidad (con fines de publicaciones científicas). Tiene una gramática propia: “suma de capas” Las capas no tienen un orden estricto salvo la primera que debe ser ggplot(). Un mismo gráfico acepta tomar información de distintos datasets Las capas se van agregando con un simbolo + Las capas básicas son: data ggplot: inicializa un objeto grafico de ggplot aesthetics aes: “Algo que se puede ver” Dentro de la capa aes debemos indicar que a que variable se atribuyen los diferentes atributos: mapeo de variables (ejes x= e y=) color exterior de los objetos o de las líneas (col) color de relleno (fill) forma de los puntos (shape) tipo de línea(linetype) tamaño de los puntos(size) geometriasgeom_: formas geométricas para representar las observaciones (dan el nombre al tipo de gráfico: grafico de dispersion, boxplot, histograma, etc…) geom_point() geom_smooth() geom_boxplot() lista de “geoms” facetasfacet_: “paneles de compartimentalización” de un mismo gráfico facet_wrap(): paneles contiguos facets_grid(): paneles tipo grilla Ejemplo de visualización con iris 5.1 Ambas variables contínuas library(tidyverse) iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Length)) geoms Objetos geométricos. Son la representación visual de las observaciones. En general los que le dan el nombre al tipo de gráfico. La lista de “geoms” aumenta día a día. iris %&gt;% ggplot(aes(x=Sepal.Length, y=Petal.Length)) + geom_point() iris %&gt;% ggplot(aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(color = Species)) iris %&gt;% ggplot(aes(x=Sepal.Length, y=Petal.Length)) + geom_point(aes(color = Species))+ geom_smooth() iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Length, color = Species)) + geom_point()+ geom_smooth() facets Las facetas o “facets” permiten dividir el mismo gráfico en múltiples paneles asociados a los niveles de un factor. p &lt;- iris %&gt;% ggplot(aes(x = Sepal.Length, y = Petal.Length)) + geom_point()+ geom_smooth(method = &quot;lm&quot;)+ facet_wrap(~Species) p theme Los temas (theme) son un conjunto de opciones predefinidas sobre la apariencia de los objetos en ggplot. El tema por defecto del ggplot dibuja el gráfico sobre un fondo gris. Podemos cambiarlo a blanco y negro añadiendo el comando theme_bw(). p + theme_bw() Si deseamos explorar las distribuciones de las variables podemos optar por un histograma o por diagramas de densidad. cowplot::plot_grid( iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_histogram()+ guides(fill=FALSE) , iris %&gt;% ggplot(aes(Petal.Length, fill=Species)) + geom_density(alpha=0.7) , align=&quot;h&quot; ) ggsave(last_plot(), file=&quot;plots/iris_histogram_dens.tiff&quot;, w=80, h=60, units=&quot;mm&quot;, dpi=300) 5.2 Comparación de niveles de factores Los gráficos de barra, ampliamente usados en publicaciones científicas, son cada vez más criticados por “ocultar” la naturaleza de las observaciones (Drummond and Vowler 2011; Weissgerber 2015) (Sugerencia: leer el box 1 del último paper). De (Drummond and Vowler 2011): Fig 1. Many different datasets can lead to the same bar graph. The full data may suggest different conclusions from the summary statistics. The means and SEs for the four example datasets shown in Panels B–E are all within 0.5 units of the means and SEs shown in the bar graph (Panel A). p-values were calculated in R (version 3.0.3) using an unpaired t-test, an unpaired t-test with Welch’s correction for unequal variances, or a Wilcoxon rank sum test. - In Panel B, the distribution in both groups appears symmetric. Although the data suggest a small difference between groups, there is substantial overlap between groups. - In Panel C, the apparent difference between groups is driven by an outlier. - Panel D suggests a possible bimodal distribution. Additional data are needed to confirm that the distribution is bimodal and to determine whether this effect is explained by a covariate. - In Panel E, the smaller range of values in group two may simply be due to the fact that there are only three observations. Additional data for group two would be needed to determine whether the groups are actually different. A continuación presentamos algunas opciones gráficas que surgen de la combinación de medidas de posición y de dispersión. #Aprovechamos para customizar el `theme` a nuestro gusto y agregar algunos detalles: p0 &lt;- iris %&gt;% ggplot(aes(x=Species, y=Sepal.Length)) + labs(x = &quot;Iris species&quot;, y =&quot;Sepal length (cm)&quot;) + theme_light(base_size = 10) 5.2.1 Observaciones + media / mediana p1 &lt;-p0 + geom_point(shape = 1, alpha=0.2)+ stat_summary(fun= mean, #median fun.min= mean, fun.max = mean, geom = &quot;point&quot;, size = 2)+ ggtitle(&quot;Observaciones (points) &amp; media&quot;) p1 # geom_dotplot(aes(fill = Species), # Use fill = Species here not in ggplot() # binaxis = &quot;y&quot;, # which axis to bin along # binwidth = 0.1, # Minimal difference considered diffeerent # stackdir = &quot;center&quot; # Centered # ) p2 &lt;- p0 + geom_jitter(width = 0.2, alpha=0.2)+ stat_summary(fun = mean, #median fun.min= mean, fun.max = mean, geom = &quot;crossbar&quot;, size = 0.5)+ ggtitle(&quot;Observaciones (jitter) &amp; media&quot;) p2 5.2.2 Barplot + SE p3 &lt;-p0 + # geom_bar(stat=&quot;identity&quot;) + stat_summary(fun=mean, position=position_dodge(width=0.95),geom=&quot;bar&quot;, colour=&quot;black&quot;,fill=&quot;grey90&quot;)+ stat_summary(fun.data=mean_cl_normal, geom=&quot;errorbar&quot;, width=0.2) + ggtitle(&quot;Barplot &amp; SEM&quot;) # geom_text(data= let, aes(label = M, x= trt, y=1, hjust=0.5),size = 4) p3 5.2.3 Box-plot p4 &lt;-p0 + geom_boxplot(fill = &quot;grey90&quot;) + ggtitle(&quot;Boxplot &amp; mean&quot;) p4 5.2.4 Violin plot p5 &lt;-p0 + geom_violin(trim=FALSE,fill = &quot;grey90&quot;)+ ggtitle(&quot;Violin plot&quot;) p5 5.2.5 Media &amp; dispersión p6 &lt;-p0 + stat_summary(fun=&quot;mean&quot;, geom=&quot;point&quot;, size=2)+ stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width=0.2)+ stat_summary(fun.data= mean_sdl, geom = &quot;errorbar&quot;, color=&quot;red&quot;, width=0.2)+ stat_summary(fun.data = mean_cl_boot, geom = &quot;errorbar&quot;, color=&quot;blue&quot;, width=0.2)+ ggtitle(&quot;Media + SE (negro) / SD (rojo) / 95% CI (negro)&quot;) p6 cowplot::plot_grid(p1, p2, p3, p4, p5, p6, ncol = 3, nrow = 2) La gran comunidad de usuarios de R disponibiliza sus creaciones e incluso trabaja en extensiones que amplían la potencialidad de sus paquetes. Se podría afirmar que no hay límites para la creación. Digamos, que no importa el “¿cómo?” si no el “¿qué?” Algunas pruebas de ello son los siguientes links: The R Graph Gallery Top 50 plots Extensiones de ggplot Fundamentals of Data Visualization El paquete ggplot2 tiene una flexibilidad tal que permite generar rápidamente gráficos exploratorios así como crear figuras complejas, detalladas, de alta calidad (con fines de publicaciones científicas). #Importación Planillas de datos - propiedades Conocer las distintas etapas del workflow de investigación confiere la gran ventaja de poder pensar nuestras acciones como parte de un todo, y no como etapas aisladas. Por ejemplo, una planilla de campo de papel de formato “apaisado” (“wide”) puede que aún no esté lista para ser analizada, pero este formato confiere ciertas ventajas prácticas (confección de planilla de papel, control interno de las evaluaciones, pasaje a planilla electrónica). Por lo tanto en una siguiente etapa luego de la importación al entorno de nuestra sesión, puede que necesitemos re-estructurarla y asi poder continuar hacia la exploración. Veamos 4 Principios básicos de buenas prácticas en la elaboración de planillas de datos - Adaptado de (Broman and Woo 2018) Como regla global, y siguiendo lo ya comentado en la la clase anterior, los dataframes tienen: columnas (verticales) que son variables y filas (horizontales) que son las observaciones (generalmente de unidades experimentales/sujetos individuales). 1 - Consistencia Sean creativos al nombrar las variables: usen 3-4 letras (minúsculas) por palabra y en caso de necesitar usar “_”. No usar acentos ni ñ. Nunca dejen espacios y maximicen el ahorro de letras, siempre y cuando se justifique, por ej: severidad = sev incidencia = inc rendimiento = rto hoja = hj (bien podría ser “hoja”) planta = pl (bien podría ser “planta”) bloque = bq temperatura = temp máxima = max Adopten siempre los mismos términos No escatimen en columnas: rep_pl -&gt; rep | pl Crear diccionario de términos: Agreguen una planilla con el detalle por extenso de las variables y sus unidades. Piensen que esa planilla la debería entender cualquier persona sin auxilio de sus propios comentarios. 2 - Rectangular Todo set de datos tiene sus dimensiones específicas: n filas - n columnas. Si se perdió alguna parcela/planta por algún motivo extra-tratamiento simplemente es un NA, y así deben definir esa observación, no poner “muerta” o “perdida.” 3 - Cero es un dato! Cero no significa ausencia de observación, en este caso podemos dejar en blanco (si se usa .xls) 4 - Planilla plana -&gt; DATOS CRUDOS SIN FÓRMULAS no combinar celdas no resaltar no hacer bordes sin negritas caracteres puros References "],["importación.html", "6 Importación 6.1 Desde PC 6.2 Desde googlesheets", " 6 Importación 6.1 Desde PC Principalmente usaremos planillas Excel guardados en nuestra computadora. Estos pueden estar guardados en formato .xlsx (planillas tradicionales) o .csv (texto separado con comas, cuando se traten de datasets muy grandes). Importemos algunos datasets característicos de uso cotidiano. Usaremos el archivo “datos_curso_unne.xls” library(tidyverse) library(readxl) que hojas tiene el archivo? excel_sheets((&quot;data/datos_curso_unne.xls&quot;)) 1 - soja: ensayo de rendimiento de 4 cultivares en un DBCA trt: cultivares bk_[1 a 4] : rendimiento en kg/ha en cada bloque ` soja &lt;- read_excel(&quot;data/datos_curso_unne.xls&quot;, sheet =&quot;soja&quot;) soja 2 - canola: medidas repetidas en el tiempo trt: tratamiento fungicida bk: bloque inc_ : % de plantas con presencia de la enfermedad phoma (incidencia) a través del tiempo termico (15, 58, 95, 146, 165, 180, 248) canola &lt;- read_excel(&quot;data/datos_curso_unne.xls&quot;, sheet =&quot;canola&quot;) 3 - bce_met: temperaturas y radiacion de 2018 fecha tmax (Cº) tmin (Cº) rad (Mj/m2) bce_met &lt;- read_excel(&quot;data/datos_curso_unne.xls&quot;, sheet =&quot;bce_met&quot;) 4 - bce_lluvias: precipitaciones de 2018 bce_lluvias &lt;- read_excel(&quot;data/datos_curso_unne.xls&quot;, sheet =&quot;bce_lluvias&quot;) 5 - maiz: rendimientos de lotes de producción del sudeste de Buenos Aires maiz &lt;- read_excel(&quot;data/datos_curso_unne.xls&quot;, sheet =&quot;maiz&quot;) 6 - triticum: [triticum.csv] triticum &lt;- read_csv(&quot;data/triticum_monococcum.csv&quot;) Una forma práctica es vía clicks de mouse en el panel de entorno de la sesión: - Buscan el archivo a importar en el explorador de archivos del panel multipropósito de RStudio - Hacen click sobre el archivo - Seleccionan “import dataset” y dan import - Configuran las opciones de importación y para que nuestro script sea reproducible copian el código generado y lo pegan en el script!\" 6.2 Desde googlesheets pacman::p_load(gsheet) url_data &lt;- &quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1579441844&quot; browseURL(url_data) Nuevamente importemos “soja” url_soja &lt;- &quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1579441844&quot; soja &lt;- gsheet2tbl(url_soja) url_mz &lt;- &quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1706724730&quot; maiz &lt;- gsheet2tbl(url_mz) Ahora compilaremos todos los dataframes importados en un archivo datos_cursos.Rdata save(soja, canola, bce_met, bce_lluvias, maiz, triticum, file=&quot;data/datos_curso.Rdata&quot;) Creamos un nuevo script, pero ahora .Rmd "],["tidyverse.html", "Tidyverse", " Tidyverse Sintaxis R base x &lt;- c(1, 2, 3, 4) sqrt(sum(x)) Como sería su equivalente bajo la sintaxis de tidyverse? library(tidyverse) x %&gt;% sum %&gt;% sqrt Volvamos a nuestros datos! load(&quot;data/datos_curso.Rdata&quot;) soja str(soja) Es evidente que necesitamos re-estructurar este dataset no? library(tidyr) # no hace falta si activamos tidyverse! Son varias las funciones útiles de este paquete, pero nos centraremos en pivot_longer(). La hermana de ésta, que cumple la funciòn inversa es pivot_wider(). Otras muy útiles funciones son separate() y unite() para separar o unir contenidos caracteres de columnas. Otras como drop_na(), complete() Full detalle de tidyr en: Sitio oficial R para ciencia de datos "],["re-estructuración.html", "7 Re-estructuración 7.1 Unir dataframes 7.2 Reordenar niveles de un factor 7.3 Modificar variables 7.4 Agregar variables", " 7 Re-estructuración pivot_longer “Wide” -&gt; “long” soja_long &lt;- soja %&gt;% pivot_longer( cols = starts_with(&quot;bk&quot;), names_to = &quot;bk&quot;, names_prefix = &quot;bk_&quot;, values_to = &quot;rinde&quot; ) soja_long Hagamos un último control de calidad… str(soja_long) soja_long &lt;- soja_long %&gt;% mutate_at(vars(trt, bk), as.factor) soja_long Ahora si, listo para un primer gráfico (por el momento no importa la apariencia)… soja_long %&gt;% ggplot() + aes(x=trt, y =rinde) + geom_point(alpha=0.2) # geom_text(aes(label=bk), hjust=2)+ # stat_summary(fun=mean, col=&quot;red&quot;) 7.1 Unir dataframes library(dplyr) # no hace falta si activamos tidyverse! En esta etapa del flujo de trabajo introduciremos {dplyr} apenas con la funciones join() y mutate(). Full detalle de dplyr en: Sitio oficial R para ciencia de datos Veamos los datos meteorologicos de Balcarce: bce_met bce_lluvias que pueden observar? bce_full &lt;- bce_met %&gt;% left_join(bce_lluvias, by=&quot;fecha&quot;) %&gt;% mutate(pp = replace_na(pp, 0)) bce_full Ahora si, veamos el data-type! bce_full bce_full &lt;- bce_full %&gt;% mutate_at(vars(fecha), lubridate::dmy) bce_full scale_x_date permite formatear los rótulos de los ejes de fchas: Podemos usaar diferentes combinaciones de dias, semanas, meses y años: nombre del mes name: %b (abreviado) o %B (completo) %d: día del mes como nro decimal %Y: año completo todas las opciones en ?strptime Temperaturas juntas en el mismo gráfico… bce_full %&gt;% ggplot() + aes(x=fecha)+ geom_line(aes(y = tmax, col = &quot;Máxima&quot;)) + geom_line(aes(y = tmin, col = &quot;Mínima&quot;)) + scale_colour_manual(&quot;&quot;, values = c(&quot;Máxima&quot; = &quot;red&quot;, &quot;Mínima&quot; = &quot;blue&quot;) )+ scale_x_date(date_breaks = &quot;1 month&quot;, date_labels = &quot;%b&quot;, limits = as.Date(c(&quot;2018-01-01&quot;, &quot;2018-31-12&quot;)))+ theme(axis.text.x = element_text(angle=45, hjust = 1)) Y lluvias? bce_full %&gt;% ggplot() + aes(x=fecha)+ geom_col(aes(y = pp)) 7.2 Reordenar niveles de un factor El paquete {forcats} podria incluirse en los logos de la taza ya que hace un aporte clave para la manipulación de los niveles de un factor. En la clase de repaso vimos este ejemplo con el dataset iris iris %&gt;% mutate( Species= fct_relevel(Species,&quot;virginica&quot;) ) %&gt;% ggplot() + aes(x=Sepal.Length)+ geom_histogram()+ facet_wrap(&quot;Species&quot;)+ theme_bw()+ labs(x= &quot;Largo del sépalo (cm)&quot;, y = &quot;Número de casos&quot;) #Modificación Hasta el momento hemos: importado nuestros datasets guardado en formato .Rdata cargado para nuevas sesiones de trabajo re-estructurado en algunos casos Ahora nos adentraremos en la modificación, creación, filtrado y sumarización de variables. Para ello usaremos a otro potente paquete del ecosistema tidyverse: Carguemos nuestros datos! load(&quot;data/datos_curso.Rdata&quot;) ls() Activemos tidyverse library(tidyverse) Las principales funciones que nos auxiliaran en esta tarea son la familia mutate Retomemos los datos meteorológicos de Balcarce 2018 bce_met bce_lluvias bce_full &lt;- bce_met %&gt;% left_join(bce_lluvias, by=&quot;fecha&quot;) bce_full Ya que lo anterior no seria eficiente tener que hacerlo en cada nueva sesión, actualicemos nuestro “banco de datos” del proyecto: (primero borremos manualmente que datasets u objetos no queremos guardar) save.image(&quot;data/datos_curso.Rdata&quot;) load(&quot;data/datos_curso.Rdata&quot;) 7.3 Modificar variables pacman::p_load(lubridate) bce_full &lt;- bce_full %&gt;% mutate(fecha = lubridate::dmy(fecha)) bce_full bce_full &lt;- bce_full %&gt;% mutate(pp = replace_na(pp, 0)) 7.4 Agregar variables Hasta aqui modificamos las variables “in-situ,” ahora agreguemos unas columnas: Extrayendo informacion de la columna fecha: bce_full &lt;- bce_full %&gt;% mutate(anio = year(fecha), mes = month(fecha), semana = week(fecha), juliano = yday(fecha)) bce_full Haciendo operaciones matemáticas/lógicas bce_full &lt;- bce_full %&gt;% mutate( tmean = (tmax + tmin) / 2, helada_agro = if_else(tmin&lt;3, TRUE, FALSE), helada_abs = if_else(tmin&lt;0, TRUE, FALSE)) bce_full O condiciones multiples bce_full &lt;- bce_full %&gt;% mutate( fav_enf = if_else(tmean&gt;20 &amp; pp&gt; 3, TRUE, FALSE) ) calcule el cociente fototermal diario siendo éste = la radiacion divido la temperatura media "],["sumarización.html", "8 Sumarización", " 8 Sumarización Temperatura media por mes bce_full %&gt;% group_by(mes) %&gt;% summarise( tmean=mean(tmean) ) Temperaturas extremas por mes bce_full %&gt;% group_by(mes) %&gt;% summarise( tmin=min(tmin), tmax=max(tmax) ) cuanto fue el mm acumulado por mes? Cuantas heladas hubieron por mes? bce_full %&gt;% group_by(mes) %&gt;% summarise( helada_agro=sum(helada_agro), helada_abs=sum(helada_abs) ) Cuantos dias llovieron “al menos” 3 mm por mes? bce_full %&gt;% group_by(mes) %&gt;% summarise(pp_3=sum(pp&gt;2)) Cuantas dias favorables para la infeccion hubieron por mes? bce_full %&gt;% group_by(mes) %&gt;% summarise(fav_enf = sum(fav_enf == TRUE)) "],["selección.html", "9 Selección", " 9 Selección Selección de variables con select y filtrado de filas con filter (ojo con el conflicto de filter!) bce_full %&gt;% select(fecha, tmean) bce_full %&gt;% select(-anio) bce_full %&gt;% select(starts_with(&quot;t&quot;)) bce_full %&gt;% select(fecha, matches(&quot;helada&quot;)) bce_full %&gt;% select(fecha, tmean) %&gt;% mutate(tmean_ayer=lag(tmean), tmean_a_ayer=lag(tmean, 2), tmean_man=lead(tmean), tmean_p_man=lead(tmean, 2)) "],["filtrado.html", "10 Filtrado", " 10 Filtrado Filtrar fechas bce_full %&gt;% filter(fecha &lt; dmy(&quot;5/1/2018&quot;)) bce_full %&gt;% filter(fecha &gt; dmy(&quot;2/1/2018&quot;), fecha &lt; dmy(&quot;5/1/2018&quot;)) Filtrar valores bce_full %&gt;% filter(tmean &gt;20) Filtrar valores multiples bce_full %&gt;% filter(tmean &gt;20, pp&gt;10) p_tmin &lt;- bce_full %&gt;% ggplot()+ aes(x=fecha, y=tmin)+ geom_line()+ geom_point(data = bce_full %&gt;% filter(tmin&lt;3), aes(x=fecha, y=0), shape=8, col=&quot;blue&quot;) eval &lt;- data.frame(fecha=dmy(c(&quot;10/10/2018&quot;,&quot;1/11/2018&quot;))) p_tmin + geom_point(data = eval, aes(x=fecha, y=20), shape=25, size=4, fill=&quot;red&quot;) "],["depuración.html", "11 Depuración 11.1 Separar - unir columnas 11.2 Depuración de variables tipo carácter 11.3 Exploración rápida del dataset 11.4 Performance de hibridos de maíz", " 11 Depuración Activemos los paquetes pacman::p_load(tidyverse, janitor, refinr, skimr) {janitor} {refinr} {skimr} Retomemos el dataset maiz url_mz &lt;- &quot;https://docs.google.com/spreadsheets/d/1c_FXVNkkj4LD8hVUForaaI24UhRauh_tWsy7sFRSM2k/edit#gid=1706724730&quot; maiz_raw &lt;- gsheet::gsheet2tbl(url_mz) maiz_raw que observan? maiz &lt;- maiz_raw %&gt;% janitor::clean_names() %&gt;% rename(has = superficie_has, rinde = rinde_qq_ha, fs=fecha_de_siembra_dd_mm) maiz 11.1 Separar - unir columnas maiz1 &lt;- maiz %&gt;% separate(campana, c(&quot;ano_siembra&quot;, &quot;ano_cosecha&quot;), remove=FALSE) %&gt;% unite(f_siembra, c(ano_siembra,fs), sep = &quot;/&quot;) %&gt;% mutate(f_siembra = lubridate::ydm(f_siembra)) maiz1 %&gt;% count(hibrido) %&gt;% arrange(hibrido) 11.2 Depuración de variables tipo carácter maiz1 %&gt;% mutate(hibrido = str_replace_all(hibrido, &quot; &quot;, &quot;&quot;)) %&gt;% mutate(hibrido = refinr::n_gram_merge(hibrido)) %&gt;% count(hibrido) %&gt;% arrange(hibrido) maiz2 &lt;- maiz1 %&gt;% mutate(hibrido = str_replace_all(hibrido, &quot; &quot;, &quot;&quot;)) %&gt;% mutate(hibrido = n_gram_merge(hibrido)) maiz2 11.3 Exploración rápida del dataset skimr::skim(maiz) Evolucion superficie por zona sup_mz &lt;- maiz2 %&gt;% group_by(zona, campana) %&gt;% summarise(super = sum(has, na.rm = TRUE) %&gt;% round) sup_mz sup_mz %&gt;% ggplot()+ aes(x = campana, y = super, fill = zona) + geom_bar(stat = &quot;identity&quot;) + geom_text(aes(label = super), position = position_stack(vjust = 0.5), col = &quot;white&quot;, fontface = &quot;bold&quot;, size = 4) Cuantos lotes por hibrido/zona maiz2 %&gt;% tabyl(hibrido,zona) %&gt;% adorn_totals() Que superficie por hibrido maiz2 %&gt;% group_by(zona, campana) %&gt;% summarise(super = sum(has)) maiz2 %&gt;% group_by(zona) %&gt;% summarise(lotes= n(), sup = sum(has, na.rm = TRUE), rinde_median = median(rinde, na.rm = TRUE), rinde_95 = quantile(rinde, .95, na.rm = TRUE)) 11.4 Performance de hibridos de maíz Filtremos el dataset: nos quedamos con aquellos hibridos presentes en al menos 10 lotes, con daño por factores abioticos &lt; 10%, y rinde &gt; 25 qq/haa hibridos &lt;- maiz2 %&gt;% drop_na(rinde) %&gt;% filter(rinde&gt;25) %&gt;% filter(dano_total&lt;10) %&gt;% group_by(hibrido) %&gt;% summarise(lotes = n(), superficie = sum(has, na.rm = TRUE), rinde_med = median(rinde, na.rm = TRUE)) %&gt;% arrange(desc(lotes)) %&gt;% group_by(hibrido) %&gt;% filter(any(lotes&gt;9)) %&gt;% select(hibrido, rinde_med, lotes) hib_mz &lt;- hibridos %&gt;% left_join(maiz2, by = &quot;hibrido&quot;) %&gt;% filter(rinde&gt;25) %&gt;% filter(dano_total&lt;10) hib_mz %&gt;% ggplot()+ aes(x=fct_reorder(hibrido, rinde_med, .desc = F), y=rinde)+ geom_boxplot(width = 0.2, fill =&quot;steelblue&quot;)+ coord_flip()+ geom_text(data=hibridos, aes(y = rinde_med, label = rinde_med), vjust = 1, size =3)+ geom_text(data=hibridos, aes(y = -Inf, label = lotes), hjust = 0, size =3)+ labs(x = &quot;&quot;, y = &quot;qq/ha&quot;, title = &quot;Rendimiento híbridos en secano&quot;, caption = &quot;- Híbridos presentes en al menos 5 lotes\\n- Nro al lado del hibrido = n° de lotes\\n- Excuidos: lotes con 10% daño x adversidades&quot;)+ theme_bw() "],["correlacion.html", "12 Correlacion", " 12 Correlacion library(tidyverse) pacman::p_load(GGally, correlation, report) # GGally iris %&gt;% ggpairs() Paquete correlation (del ecosistema easystats) # correlation iris %&gt;% correlation(method = &quot;pearson&quot;) #spearman iris %&gt;% ggpairs(aes(color = Species)) iris %&gt;% dplyr::select(Species, Sepal.Length, Sepal.Width, Petal.Width) %&gt;% group_by(Species) %&gt;% correlation() "],["regresión-linear.html", "13 Regresión linear", " 13 Regresión linear pacman::p_load(jtools, report) model &lt;- iris %&gt;% lm(formula = Sepal.Length ~ Petal.Width) # R base anova(model) summary(model) # jtools summ(model) library(ggfortify) autoplot(model) Paquete report report(model) Agregar formula y R2 library(ggpmisc) formu &lt;- y ~ x ggplot(iris, aes(x=Petal.Width, y=Sepal.Length))+ geom_point() + geom_smooth(method=&quot;lm&quot;)+ stat_poly_eq(formula = formu, aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), parse = TRUE) # geom_abline(slope = coef(model)[[2]], intercept = coef(model)[[1]]) # geom_line(data = fortify(model), aes(x=Petal.Width, y = .fitted)) Paquete jtools effect_plot(model, pred=Petal.Width, plot.points = TRUE, interval = TRUE, colors = &quot;red&quot;)+ theme_bw() Paquete ggeffects res_reg &lt;- ggpredict(model, terms =&quot;Petal.Width&quot;) res_reg %&gt;% ggplot()+ aes(x=x, y=predicted)+ geom_line() plot(res_reg, ci = FALSE) + labs(x = &quot;Ancho de pétalos&quot;) + geom_point(data=iris, aes(x=Petal.Width, y=Sepal.Length)) Regresión polinomial fit2 &lt;- lm(dist ~ speed + I(speed^2), data = cars) summary(fit2) # fit3 &lt;- lm(dist ~ poly(speed,2, raw = TRUE), data = cars) # summary(fit3) effect_plot(fit2, pred=speed, plot.points = TRUE, interval = TRUE, colors = &quot;red&quot;) ggplot(cars, aes(x=speed, y=dist) ) + geom_point() + stat_smooth(method = lm, formula = y ~ poly(x, 2, raw = TRUE)) "],["anova.html", "14 Anova Un solo factor Dos factores", " 14 Anova library(tidyverse) Un solo factor experimento DCA: dataset PlantGrowth ?PlantGrowth pg &lt;- PlantGrowth # simplificamos el nombre del dataset Exploración str(pg) # tipo de variables summary(pg) # exploración numérica Exploración numérica pg %&gt;% group_by(group) %&gt;% summarise( n= sum(!is.na(weight)), mean = mean(weight), sd = sd(weight), se = sd(weight)/sqrt(n)) Exploración gŕafica pg %&gt;% ggplot(aes(x=group, y=weight)) + geom_boxplot(width=0.2)+ geom_jitter(alpha=0.2, width=0.1) Ajuste del modelo lineal \\[y_{ij} = \\mu + \\alpha_i + e_{ij}; \\:\\:i = 1,..., k; \\:j = 1,..., n\\] \\[N \\sim (\\sigma^2, 0)\\] mod1 &lt;- lm(weight ~ group, data = pg) Diagnósticos ¿Las varianzas (entre niveles del factor) son homogéneas? # homocedasticidad plot(mod1, which = 1) car::leveneTest(mod1) ¿Los residuos se distribuyen normales? plot(mod1, which = 2) shapiro.test(rstandard(mod1)) anova(mod1)# caso balanceado summary(mod1) # car::Anova(mod1)# caso desbalanceado Test de comparaciones múltiples (de medias estimadas de los tratamientos) Paquete emmeans pacman::p_load( emmeans, # medias estimadas por el modelo multcomp # comparar las medias entre si - tukey ) Medias e intervalos de confianza estimadas por el modelo em &lt;- emmeans(mod1, ~ group, type=&quot;response&quot;) em Comparaciones múltiples res &lt;- cld(em, Letters = letters, reverse = FALSE, alpha = .05) res plot(res) res_tbl &lt;- res %&gt;% as_tibble() Graficar los resultados obtenidos del anova Opción A) p1 &lt;- res_tbl %&gt;% mutate(group = fct_relevel(group, &quot;ctrl&quot;, &quot;trt1&quot;)) %&gt;% ggplot() + aes(x=group, y=emmean)+ geom_pointrange(aes(ymin = lower.CL, ymax = upper.CL))+ geom_jitter(data = pg %&gt;% rename(&quot;emmean&quot; = weight), aes(x = group, y = emmean), width = .1, alpha=0.2) + geom_hline( yintercept = filter(res_tbl, group==&quot;ctrl&quot;) %&gt;% pull(emmean), linetype = 2, col =&quot;gray50&quot;)+ labs(x = &quot;Tratamiento&quot;, y = &quot;Peso (g)&quot;)+ scale_y_continuous(breaks=scales::breaks_pretty(6))+ geom_text(vjust=-1, angle=90, aes(label = str_squish(.group)))+ theme_bw() p1 Opción B) p2 &lt;- res_tbl %&gt;% mutate(group = fct_relevel(group, &quot;ctrl&quot;, &quot;trt1&quot;)) %&gt;% ggplot() + aes(x=group, y=emmean)+ geom_col(width=0.4)+ geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width=0.1)+ geom_hline( yintercept = filter(res_tbl, group==&quot;ctrl&quot;) %&gt;% pull(emmean), linetype = 2, col =&quot;gray50&quot;)+ labs(x = &quot;Tratamiento&quot;, y = &quot;Peso (g)&quot;)+ scale_y_continuous(breaks=scales::breaks_pretty(6), limits = c(0,7))+ geom_text(vjust=-2, aes(label = str_squish(.group)))+ theme_bw() p2 pacman::p_load(patchwork) p1 + p2 + plot_annotation(title = &#39;Alternativas de presentación de resultados&#39;, tag_levels = &#39;A&#39;, subtitle = &quot;A) geom_pointrange() + geom_jitter()\\nB) geom_col() + geom_errorbar()&quot;) Como graficaríamos con el mismo dataset - sin cálculos previos pg %&gt;% ggplot()+ aes(x=group, y = weight) + stat_summary(fun=mean, geom=&quot;bar&quot;, col=&quot;black&quot;, fill= &quot;lightgrey&quot;, width=.5) + stat_summary(fun.data = mean_se, geom = &quot;errorbar&quot;, width=.1)+ labs(x = &quot;Tratamiento&quot;, y = &quot;Peso (g)&quot;)+ scale_y_continuous(breaks=scales::breaks_pretty(6), limits = c(0,7))+ theme_bw() Comparación de medias de los trat vs testigo (Dunnet) contrast(em, &quot;trt.vs.ctrl1&quot;) Comparación de medias por LSD library(agricolae) res_lsd &lt;- LSD.test(y = mod1, trt = &quot;group&quot;, group = T, console = T) res_lsd bar.group(x = res_lsd$groups, ylim=c(0, 7), # main=&quot;Prueba de comparación de medias por medio del método LSD&quot;, # xlab=&quot;Tipo de Mezcla&quot;, # ylab=&quot;Rendimiento del proceso&quot;, col=&quot;steelblue&quot;) save(list=ls(), file=&quot;anova_report.Rda&quot;) Dos factores library(tidyverse) ?ToothGrowth tg &lt;- ToothGrowth Exploración str(tg) # tipo de variables tg1 &lt;- tg %&gt;% mutate_at(vars(dose), as.factor) summary(tg1) # exploración numérica # exploracion numerica por tratamiento tg1 %&gt;% group_by(supp, dose) %&gt;% summarise( count = sum(!is.na(len)), mean = mean(len, na.rm = TRUE), sd = sd(len, na.rm = TRUE) ) pacman::p_load(plotly) # Exploración gŕafica tg %&gt;% ggplot() + aes(x = dose, y = len, col = supp)+ # geom_line() + geom_line(stat = &quot;summary&quot;, fun=mean) + geom_point() tg1 %&gt;% ggplot(aes(x = dose, y = len, col = supp)) + geom_boxplot() + facet_wrap(&quot;supp&quot;) tg1 %&gt;% ggplot(aes(x = supp, y = len, col = supp)) + geom_boxplot() + facet_wrap(&quot;dose&quot;) p2 &lt;- tg1 %&gt;% ggplot(aes(x = dose, y = len, col = supp)) + geom_boxplot() + geom_point(position=position_jitterdodge())+ labs(title = &quot;ToothGrowth Data&quot;, y = &quot;Length of Odontoblast Cells&quot;, x = &quot;Dosage of Vitamin C&quot;, fill = &quot;Vitamin C Type&quot;) ggplotly(p2) Ajustar modelo mod2 &lt;- lm(len ~ supp * dose, data=tg1) # equivale a supp + dose + supp:dose Diagnósticos ¿Las varianzas (entre niveles del factor) son homogéneas? # homocedasticidad plot(mod2, which = 1) car::leveneTest(mod2) # bartlett.test(len~dose, data=tg1)$p.value ¿Los residuos se distribuyen normales? plot(mod2, which = 2) shapiro.test(rstandard(mod2)) anova(mod2) comparaciones múltiples (un factor dentro del otro) pacman::p_load(emmeans, multcomp, multcompView) # emmip(mod2, supp~ dose) posthoc &lt;- emmeans(mod2, pairwise ~ supp|dose, adjust=&quot;tukey&quot;) cld(posthoc$emmeans, alpha=.05, Letters=letters) posthoc1 &lt;- emmeans(mod2, pairwise ~ dose|supp, adjust=&quot;tukey&quot;) cld(posthoc1$emmeans, alpha=.05, Letters=letters) posthoc2&lt;-emmeans(mod2, pairwise~supp*dose, adjust=&quot;tukey&quot;) cld(posthoc2$emmeans, alpha=.05, Letters=letters) emmip(mod2, ~ supp | dose) library(ggeffects) ggpredict(mod2, terms = c(&quot;dose&quot;, &quot;supp&quot;)) %&gt;% plot() library(lme4) # pacman::p_load(lmerTest) fm1 &lt;- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) anova(fm1) car::Anova(fm1) Transformación potencia óptima de boxcox Esta transformación sólo tiene un parámetro: lambda, graficado en el eje x. Si el valor de lambda es igual a cero, se lleva a cabo la transformación con el logaritmo natural, y si dicho valor es distinto a cero la transformación es potencial. Si el parámetro lambda es igual a uno, no hace falta transformar la variable respuesta. Si el intervalo (líneas punteadas verticales) no contiene a 0 ni a 1, hay que transformar la variable elevando a la potencia del valor de lamba incluido en el intervalo. La utilización de la transformación Box-Cox requiere que todos los valores de la serie de entrada sean positivos y distintos a cero. Por ello es adicionada una constante a la variable original (0.5, por ej.). En el caso de la derecha, el modelo resultaría: lm((y+0.5)^0.2 ~ trt + bk, ...) Lexturas recomendadas Analysis and Interpretation of Interactions in Agricultural Research Analysis of Combined Experiments Revisited Model Syntax in R ANOVA: A Short Intro Using R glmmFAQ A brief introduction to mixed effects modelling and multi-model inference in ecology Data Analysis Examples Data Analysis and Visualization in R for Ecologists RNAseq analysis with R ::: "],["r-markdown.html", "15 R Markdown Elementos básicos de R Markdown Formateo de texto con Markdown Encabezados Listas Enlaces e imágenes Tablas Bloques de código Tablas Opciones globales", " 15 R Markdown R Markdown provee un marco de escritura para ciencia de datos, que combina tu código, sus resultados y tus comentarios en prosa. Los documentos de R Markdown son completamente reproducibles y soportan docenas de formatos de salida tales como PDFs, archivos de Word, presentaciones y más. Los archivos R Markdown están diseñados para ser usados de tres maneras: Para comunicarse con quienes toman decisiones, que desean enfocarse en las conclusiones, no en el código que subyace al análisis. Para colaborar con otras personas que hacen ciencia de datos, quienes están interesados tanto en tus conclusiones como en el modo en el que llegaste a ellas (es decir, el código). Como si fuera un notebook de laboratorio moderno donde puedes capturar no solo que hiciste, sino también lo que estabas pensando cuando lo hacías. Elementos básicos de R Markdown Este es un archivo R Markdown, un archivo de texto plano que tiene la extensión .Rmd: Contiene tres tipos importantes de contenido: Un encabezado YAML (opcional) rodeado de ---s. Chunks de código de R rodeados de ```. Texto mezclado con formateos de texto simple como # Encabezado e _italicas_. Cuando abres un archivo .Rmd, obtienes una interfaz de notebook donde el código y el output están intercalados. Puedes ejecutar cada bloque de código haciendo clic en el ícono ejecutar (se parece a un botón de reproducir en la parte superior del bloque de código), o presionando Ctrl + Shift + Enter. RStudio ejecuta el código y muestra los resultados incustrados en el código. Para producir un reporte completo que contenga todo el texto, código y resultados, haz clic en “Knit” o presionar Ctrl + Shift + K. Esto mostrará el reporte en el panel viewer y creará un archivo HTML independiente que puedes compartir con otras personas Formateo de texto con Markdown Formato de texto cursiva o cursiva negrita negrita code superíndice2 y subíndice2 Encabezados Encabezado de primer nivel Encabezado de segundo nivel Encabezado de tercer nivel Listas Elemento 1 en lista no enumerada Elemento 2 Elemento 2a Elemento 2b Elemento 1 en lista enumerada Elemento 2. La numeración se incrementa automáticamente en el output. Enlaces e imágenes https://es.r4ds.hadley.nz/ Español https://r4ds.had.co.nz/ Inglés texto del enlace pie de página opcional Tablas Primer encabezado Segundo encabezado Contenido de la celda Contenido de la celda Contenido de la celda Contenido de la celda Bloques de código Para ejecutar código dentro de un documento R Markdown, necesitas insertar un bloque o chunk, en inglés. Hay tres maneras para hacerlo: Con el atajo de teclado: Cmd/Ctrl + Alt + I Con el ícono “Insert” en la barra de edición Tipeando manualmente los delimitadores de bloque ```{r} y ```. Obviamente, nuestra recomendación es que aprendas a usar el atajo de teclado. A largo plazo, te ahorrará mucho tiempo. Puedes continuar ejecutando el código usando el atajo de teclado que para este momento (¡esperamos!) ya conoces y amas : Cmd/Ctrl + Enter. Sin embargo, los bloques de código tienen otro atajo de teclado: Cmd/Ctrl + Shift + Enter, que ejecuta todo el código en el bloque. Piensa el bloque como una función. Un bloque debería ser relativamente autónomo y enfocado en torno a una sola tarea. Las siguientes secciones describen el encabezado de bloque, que consiste en Opciones de los bloques La salida de los bloques puede personalizarse con options, que son argumentos suministrados en el encabezado del bloque. Knitr provee casi 60 opciones que puedes usar para personalizar tus bloques de código. Aquí cubriremos las opciones de bloques más importantes que usarás más frecuentemente. Puedes ver la lista completa en http://yihui.name/knitr/options/. El conjunto más importante de opciones controla si tu bloque de código es ejecutado y qué resultados estarán insertos en el reporte final: eval = FALSE evita que el código sea evaluado. (Y, obviamente, si el código no es ejecutado no se generaran resultados). Esto es útil para mostrar códigos de ejemplo, o para deshabilitar un gran bloque de código sin comentar cada línea. include = FALSE ejecuta el código, pero no muestra el código o los resultados en el documento final. Usa esto para código de configuración que no quieres que abarrote tu reporte. echo = FALSE evita que se vea el código, pero sí muestra los resultados en el archivo final. Utiliza esto cuando quieres escribir reportes enfocados a personas que no quieren ver el código subyacente de R. message = FALSE o warning = FALSE evita que aparezcan mensajes o advertencias en el archivo final. results = 'hide' oculta el output impreso; fig.show = ‘hide’ oculta gráficos. error = TRUE causa que el render continúe incluso si el código devuelve un error. Esto es algo que raramente quieres incluir en la versión final de tu reporte, pero puede ser muy útil si necesitas depurar exactamente qué ocurre dentro de tu .Rmd. Es también útil si estás enseñando R y quieres incluir deliberadamente un error. Por defecto, error = FALSE provoca que el knitting falle si hay incluso un error en el documento. La siguiente tabla resume qué tipos de output suprime cada opción: Option Ejecuta Muestra Output Gráficos Mensajes Advertencias eval = FALSE - - - - - include = FALSE - - - - - echo = FALSE - results = \"hide\" - fig.show = \"hide\" - message = FALSE - warning = FALSE - Tablas Por defecto, R Markdown imprime data frames y matrices tal como se ven en la consola: head(mtcars) Si prefieres que los datos tengan formato adicional, puedes usar la función knitr::kable knitr::kable( head(mtcars), caption = &quot;A knitr kable.&quot; ) Opciones globales A medida que trabajes más con knitr, descubrirás que algunas de las opciones de bloque por defecto no se ajustan a tus necesidades y querrás cambiarlas. Puedes hacer esto incluyendo knitr::opts_chunk$set() en un bloque de código. Por ejemplo, cuando escribimos un reporte para una persona no interesada en el código incluiremos en el seteo global: ## Global options knitr::opts_chunk$set( echo=FALSE, comment=NA, message=FALSE, warning=FALSE) Esto ocultará por defecto el código, así que solo mostrará los bloques que deliberadamente has elegido mostrar (con echo = TRUE). Más info sobre R Markdown en https://es.r4ds.hadley.nz/r-markdown.html "],["trabajo-final-de-curso.html", "16 Trabajo final de curso", " 16 Trabajo final de curso Pasos básicos para la elaboración del informe de proyectos personales importación de datos desde la propia PC o desde Google sheet renombre de variables descripción de Data frame y clases de clases de variables exploración numérica de los datos exploración gráfica de los datos ajuste de algún modelo gráfico final conclusiones por extenso en escrito NOTA: son mas que bienvenidos todos los agregados personales que quieran hacer (incluir imágenes sobre los datasets, mapas, etc…) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
